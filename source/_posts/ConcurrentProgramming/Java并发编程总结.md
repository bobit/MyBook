---
title: Java并发编程总结
toc: true
typora-copy-images-to: ../../gitbooks/static/images/
mathjax: true
abbrlink: 1d1988c1
date: 2014-11-13 18:24:18
tags:
  - 并发
  - concurrent
categories:
  - ConcurrentProgramming
---

## 多线程的基本知识
### 进程与线程的介绍
　　程序运行时在内存中分配自己独立的运行空间，就是进程
　　线程：它是位于进程中，负责当前进程中的某个具备独立运行资格的空间。
　　进程是负责整个程序的运行，而线程是程序中具体的某个独立功能的运行。一个进程中至少应该有一个线程。
### 多线程的介绍
　　在多任务，多用户的系统中。每天都会产生许多进程。
　　多线程：在一个进程中，我们同时开启多个线程，让多个线程同时去完成某些任务（功能）。
　　(比如后台服务系统，就可以用多个线程同时响应多个客户的请求)
　　多线程的目的：提高程序的运行效率。
　　多线程的运行原理：cpu在线程中做时间片的切换（多线程可以提高程序的运行效率，但不能无限制的开线程）
### 实现线程的两种方式
　　1、继承Thread的方式
　　2、声明实现 Runnable 接口的方式
### JAVA同步 synchronized关键字
　　#### 加同步格式：
　　synchronized( 需要一个任意的对象（锁） ){
　　代码块中放操作共享数据的代码}
　　#### 释放锁
　　synchronized是java中的一个关键字，也就是说是Java语言内置的特性。如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：
　　1.获取锁的线程执行完了该代码块，然后线程释放对锁的占有
　　2.线程执行发生异常，此时JVM会让线程自动释放锁。
　　#### synchronized缺点
　　所以synchronized等待线程能无期限地等待下去：这是一个致命的缺点，所以引进了Lock解决这个问题。

### lock
#### lock和synchronized的区别
　　1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；
　　2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。
#### 关于 Lock和synchronized的选择
　　1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；
　　2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；
　　3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；
　　4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。
　　5）Lock可以提高多个线程进行读操作的效率。
　　在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。
#### Lock接口中每个方法的使用：
　　lock()、tryLock()、tryLock(long time, TimeUnit unit)、lockInterruptibly()是用来获取锁的。
　　unLock()方法是用来释放锁的。
#### 四个获取锁方法的区别：
   lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。
   由于在前面讲到如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。
   tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。
　　tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。
　　lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。
　　注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。
　　因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。
　　而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。ReentrantLock
   直接使用lock接口的话，我们需要实现很多方法，不太方便，ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法，ReentrantLock，意思是“可重入锁”。


## 进程与线程

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。

　　线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。

　　**进程和线程的关系：**

　　(1)一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。

　　(2)资源分配给进程，同一进程的所有线程共享该进程的所有资源。

　　(3)处理机分给线程，即真正在处理机上运行的是线程。

　　(4)线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。

　　**进程与线程的区别:**

　　(1)调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位

　　(2)并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行

　　(3)拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源.

　　(4)系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些

　　结论：

　　(1)线程是进程的一部分

　　(2)CPU调度的是线程

　　(3)系统为进程分配资源，不对线程分配资源


**进程**
进程通常分为就绪、运行和阻塞三个工作状态。三种状态在某些条件下可以转换，三者之间的转换关系如下：
进程三个状态之间的转换就是靠PV操作来控制的。PV操作主要就是P操作、V操作和信号量。其中信号量起到了至关重要的作用。

**PV操作**
在计算机操作系统中，PV操作是进程管理中的难点。
首先应弄清PV操作的含义：PV操作由P操作原语和V操作原语组成（原语是不可中断的过程），对信号量进行操作，具体定义如下：
    P（S）：①将信号量S的值减1，即S=S-1；
           ②如果S³0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。
    V（S）：①将信号量S的值加1，即S=S+1；
           ②如果S>0，则该进程继续执行；否则释放队列中第一个等待信号量的进程。
PV操作的意义：我们用信号量及PV操作来实现进程的同步和互斥。PV操作属于进程的低级通信。

**信号量**
信号量是最早出现的用来解决进程同步与互斥问题的机制。　

什么是信号量？

信号量（Saphore）由一个值和一个指针组成，指针指向等待该信号量的进程。信号量的值表示相应资源的使用情况。信号量S>=0时，S表示可用资源的数量。执行一次P操作意味着请求分配一个资源，因此S的值减1；当S<0时，表示已经没有可用资源，S的绝对值表示当前等待该资源的进程数。请求者必须等待其他进程释放该类资源，才能继续运行。而执行一个V操作意味着释放一个资源，因此S的值加1；若S<0，表示有某些进程正在等待该资源，因此要唤醒一个等待状态的进程，使之运行下去。

注意，信号量的值只能由PV操作来改变。


**关于PV操作容易产生的一些疑问：**

1，S大于0那就表示有临界资源可供使用，为什么不唤醒进程？
S大于0的确表示有临界资源可供使用，也就是说这个时候没有进程被阻塞在这个资源上，所以不需要唤醒。

2，S小于0应该是说没有临界资源可供使用，为什么还要唤醒进程？
V原语操作的本质在于：一个进程使用完临界资源后，释放临界资源，使S加1，以通知其它的进程，这个时候如果S<0，表明有进程阻塞在该类资源上，因此要从阻塞队列里唤醒一个进程来“转手”该类资源。比如，有两个某类资源，四个进程A、B、C、D要用该类资源，最开始S=2，当A进入，S=1，当B进入S=0，表明该类资源刚好用完， 当C进入时S=-1，表明有一个进程被阻塞了，D进入，S=-2。当A用完该类资源时，进行V操作，S=-1，释放该类资源，因为S<0，表明有进程阻塞在该类资源上，于是唤醒一个。

3，如果是互斥信号量的话，应该设置信号量S=1，但是当有5个进程都访问的话，最后在该信号量的链表里会有4个在等待，也是说S=-4，那么第一个进程执行了V操作使S加1，释放了资源，下一个应该能够执行，但唤醒的这个进程在执行P操作时因S<0，也还是执行不了，这是怎么回事呢？

当一个进程阻塞了的时候，它已经执行过了P操作，并卡在临界区那个地方。当唤醒它时就立即进入它自己的临界区，并不需要执行P操作了，当执行完了临界区的程序后，就执行V操作。

4，S的绝对值表示等待的进程数，同时又表示临界资源，这到底是怎么回事？

当信号量S小于0时，其绝对值表示系统中因请求该类资源而被阻塞的进程数目.S大于0时表示可用的临界资源数。注意在不同情况下所表达的含义不一样。当等于0时，表示刚好用完。

以上就是我对PV操作的一些肤浅理解，还请多多指教。

**利用信号量和PV操作实现进程互斥的一般模型是：**
进程P1              进程P2           ……          进程Pn
……                  ……                           ……
P（S）；              P（S）；                         P（S）；
临界区；             临界区；                        临界区；
V（S）；              V（S）；                        V（S）；
……                  ……            ……           ……

其中信号量S用于互斥，初值为1。
使用PV操作实现进程互斥时应该注意的是：
（1）每个程序中用户实现互斥的P、V操作必须成对出现，先做P操作，进临界区，后做V操作，出临界区。若有多个分支，要认真检查其成对性。
（2）P、V操作应分别紧靠临界区的头尾部，临界区的代码应尽可能短，不能有死循环。
（3）互斥信号量的初值一般为1。

**利用信号量和PV操作实现进程同步**
PV操作是典型的同步机制之一。用一个信号量与一个消息联系起来，当信号量的值为0时，表示期望的消息尚未产生；当信号量的值非0时，表示期望的消息已经存在。用PV操作实现进程同步时，调用P操作测试消息是否到达，调用V操作发送消息。
    使用PV操作实现进程同步时应该注意的是：

（1）分析进程间的制约关系，确定信号量种类。在保持进程间有正确的同步关系情况下，哪个进程先执行，哪些进程后执行，彼此间通过什么资源（信号量）进行协调，从而明确要设置哪些信号量。
（2）信号量的初值与相应资源的数量有关，也与P、V操作在程序代码中出现的位置有关。
（3）同一信号量的P、V操作要成对出现，但它们分别在不同的进程代码中。
