---
title: 面试题-vipkid面试题
toc: true
typora-copy-images-to: ../../gitbooks/static/images/
mathjax: true
abbrlink: 75533f3e
tags:
  - Interview
categories:
  - Interview
date: 2017-12-29 17:16:18
---
vipkid 面试经历
今天下午去了位于钟鼓楼旁边的 vipkid 研发部进行了面试，面试过程中的回答只能说一般，面试官问的问题大概分为：

### 实际项目的设计问题

### mysql的使用优化问题
 a) 选择合适的字段，比如邮箱字段可以设为char（6），尽量把字段设置为not null，这样查询的时候数据库就不需要比较null值  
 b) 使用关联查询（ left join on）查询代替子查询  
 c) 使用union联合查询手动创建临时表  
 d) 开启事务，当数据库执行多条语句出现错误时，事务会回滚，可以维护数据库的完整性 
 e) 使用外键，事务可以维护数据的完整性但是它却不能保证数据的关联性，使用外键可以保证数据的关联性 
 f) 使用索引，索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快的多的速度检索特定的行，特别是对于max，min，order by查询时，效果更明显  
 g) 优化的查询语句，绝大多数情况下，使用索引可以提高查询的速度，但如果sql语句使用不恰当的话，索引无法发挥它的特性。 


### 多线程与锁的问题

多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。
最简单的比喻多线程就像火车的每一节车厢，而进程则是火车。车厢离开火车是无法跑动的，同理火车也不可能只有一节车厢。多线程的出现就是为了提高效率。

互斥锁

  每个对象都对应一个互斥锁标记，可以保证在某一时刻只能有一个线程访问该对象。
  互斥锁的关键字 synchronized 可以写在某个方法上（代表锁调用该方法的对象）；  可以括在要锁的语句外。
好处：解决了线程安全的问题
弊端：降低了运行效率（判断锁，且不能共享信息）；容易出现死锁。

死锁：

两个线程A，B用到同一个对象s(s为共享资源)，且线程A在执行中要用到B运行后所创造条件。在这种前提下A先开始运行，进入同步块后，对象s被锁定，接着线程A因等待B运行结束而进入阻塞状态，于是B开始运行，但因无法访问对象s，线程B也进入阻塞状态，等待s被线程A解锁。最终的结果：两个线程互相等待，都无法运行。


### JVM底层原理的问题
JVM的生命周期
一、首先分析两个概念
　　 JVM实例和JVM执行引擎实例
　　（1）JVM实例对应了一个独立运行的java程序，它是进程级别。
　　（2）JVM执行引擎实例则对应了属于用户运行程序的线程，它是线程级别的。
二、JVM的生命周期
　　（1）JVM实例的诞生：当启动一个Java程序时，一个JVM实例就产生了，任何一个拥有public static void main(String[] args)函数的class都可以作为JVM实例运行的起点。 
　　（2）JVM实例的运行 main()作为该程序初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM自己使用，java程序也可以标明自己创建的线程是守护线程。 
　　（3）JVM实例的消亡：当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用Runtime类或者System.exit()来退出。

 JVM的体系结构
　　一、JVM的内部体系结构分为三部分，
　　（1）类装载器（ClassLoader）子系统
　　　　　作用: 用来装载.class文件
　　（2）执行引擎
　　　　　作用:执行字节码，或者执行本地方法
　　（3）运行时数据区
　　　　　方法区，堆，java栈，PC寄存器，本地方法栈

JVM类加载器

一、 JVM将整个类加载过程划分为了三个步骤：
（1）装载
　　装载过程负责找到二进制字节码并加载至JVM中，JVM通过类名、类所在的包名通过ClassLoader来完成类的加载，同样，也采用以上三个元素来标识一个被加载了的类：类名+包名+ClassLoader实例ID。
（2）链接
　　链接过程负责对二进制字节码的格式进行校验、初始化装载类中的静态变量以及解析类中调用的接口、类。在完成了校验后，JVM初始化类中的静态变量，并将其值赋为默认值。最后一步为对类中的所有属性、方法进行验证，以确保其需要调用的属性、方法存在，以及具备应的权限（例如public、private域权限等），会造成NoSuchMethodError、NoSuchFieldError等错误信息。
（3）初始化
　　初始化过程即为执行类中的静态初始化代码、构造器代码以及静态属性的初始化，在四种情况下初始化过程会被触发执行：调用了new；反射调用了类中的方法；子类调用了初始化；JVM启动过程中指定的初始化类。

二、JVM两种类装载器包括：启动类装载器和用户自定义类装载器：
　　启动类装载器是JVM实现的一部分，用户自定义类装载器则是Java程序的一部分，必须是ClassLoader类的子类。

　　主要分为以下几类：
　　(1) Bootstrap ClassLoader
　　这是JVM的根ClassLoader，它是用C++实现的，JVM启动时初始化此ClassLoader，并由此ClassLoader完成$JAVA_HOME中jre/lib/rt.jar（Sun JDK的实现）中所有class文件的加载，这个jar中包含了java规范定义的所有接口以及实现。
　　(2) Extension ClassLoader
　　JVM用此classloader来加载扩展功能的一些jar包
　　(3) System ClassLoader
　　JVM用此classloader来加载启动参数中指定的Classpath中的jar包以及目录，在Sun JDK中ClassLoader对应的类名为AppClassLoader。
　　(4) User-Defined ClassLoader
　　User-DefinedClassLoader是Java开发人员继承ClassLoader抽象类自行实现的ClassLoader，基于自定义的ClassLoader可用于加载非Classpath中的jar以及目录

三、ClassLoader抽象类提供了几个关键的方法：
（1）loadClass
（2）findLoadedClass
 （3） findClass
 (4) findSystemClass
 (5)defineClass 
 (6) resolveClass

为什么一些程序频繁发生GC？有如下原因： 
1. 程序内调用了System.gc()或Runtime.gc()。 
2. 一些中间件软件调用自己的GC方法，此时需要设置参数禁止这些GC。 
3. Java的Heap太小，一般默认的Heap值都很小。 
4. 频繁实例化对象，Release对象。此时尽量保存并重用对象，例如使用StringBuffer和String。

如果每次GC后，Heap的剩余空间会是总空间的50%，这表示你的Heap处于健康状态。许多Server端的Java程序每次GC后最好能有65%的剩余空间。
注意：
增加Heap的大小虽然会降低GC的频率，但也增加了每次GC的时间。并且GC运行时，所有的用户线程将暂停，也就是GC期间，Java应用程序不做任何工作。
Heap大小并不决定进程的内存使用量。进程的内存使用量要大于-Xmx定义的值，因为Java为其他任务分配内存，例如每个线程的Stack等。
每个线程都有他自己的Stack,Stack的大小限制着线程的数量。如果Stack过大就好导致内存溢漏
硬件环境也影响GC的效率，例如机器的种类，内存，swap空间，和CPU的数量。如果你的程序需要频繁创建很多transient对象，会导致JVM频繁GC。这种情况你可以增加机器的内存，来减少Swap空间的使用


JVM如何判断一个对象为垃圾
这个时候就要考虑JVM什么时候才把一个对象当成垃圾了，常用的有以下几种方法：
引用计数器算法

JVM操作cpu与内存交互的工作原理
在C/C++中，它们的工作原理是 
先将语句转化为汇编， 
再把汇编转换为二进制数据传给CPU， 
cpu通过控制总线来控制cpu的地址总线寻找内存地址,数据总线传送数据到内存单元中。获得数据实现与内存的交互。

而在Java这一块来说的话，编译成.class文件（它是一个字节码文件）之后，这个时候cpu就相当于可以和他进行交互了，而jvm就负责在中间这一块去识别它。如果照上面的C/C++的逻辑来说，.class可以理解为cpu可以理解的语言了（JVM负责翻译）。


JVM在整个jdk(java 运行环境)中处于最底层,负责与操作系统的交互,用来屏蔽操作系统环境,提供一个完整的Java运行环境,因此也就虚拟计算机. 操作系统装入JVM是通过jdk中Java.exe来完成,通过下面4步来完成JVM环境. 
1.创建JVM装载环境和配置 
2.装载JVM.dll 
3.初始化JVM.dll并挂界到JNIENV(JNI调用接口)实例 
4.调用JNIEnv实例装载并处理class类。

### hashmap 以及 concurenthashmap 实现以及使用问题

从JDK1.2起，就有了HashMap，HashMap不是线程安全的，因此多线程操作时需要格外小心。
在JDK1.5中，伟大的Doug Lea给我们带来了concurrent包，从此Map也有安全的了。

ConcurrentHashMap具体是怎么实现线程安全的呢，肯定不可能是每个方法加synchronized，那样就变成了HashTable。
从ConcurrentHashMap代码中可以看出，它引入了一个“分段锁”的概念，具体可以理解为把一个大的Map拆分成N个小的HashTable，根据key.hashCode()来决定把key放到哪个HashTable中。
在ConcurrentHashMap中，就是把Map分成了N个Segment，put和get的时候，都是现根据key.hashCode()算出放到哪个Segment中;

ConcurrentHashMap的工作机制，通过把整个Map分为N个Segment（类似HashTable），可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。

基本上就这些了，并没有算法方面的问题。除了第三点和第五点能说的全面一点，其他三点我基本上是没回答多少。没办法，个人能力太差。面试官人还不错，然后说我基础还行，但是他们组现在想招几个高级工程师，不要我这种初级的，所以只能推荐给其他组试试了。那试试就试试吧。。。
实际面试问题：

### 说一个自己曾经做过的项目的架构。然后我说了一个app项目的后台服务

### 然后说一下app项目的后台服务都有哪些特点？

### 如何做到接口的安全性，不被越权？
保护API的关键在于确保您充分了解威胁模型以及防御方式:

1）、平面隔离，确定接口所属平面，且平面已清晰隔离等。

2）、安全传输，安全传输是否已默认启用，相关算法、套件以及证书管理符合要求等。

3）、认证，默认账户公开，强口令策略，防暴力破解机制以及会话管理机制等

4）、鉴权，确保所有接口都已鉴权，不存在横向和纵向越权问题，不存在直接对象引用问题等。

5）、敏感数据和隐私保护，敏感数据均需要加密存储及传输，加密算法符合要求，文件权限控制得当。

6）、web安全，如果是WebApi接口，需要考虑覆盖web安全相关内容，如文件上传下载、输入编码输出校验、参数服务端校验等

7）、接口Fuzz，对于接口需要从传输层、应用层分别考虑协议的Fuzz，包括应用层API接口Fuzz

8）、泛洪攻击，从传输层、应用层以及鉴权未鉴权消息角度分别考虑DOS、DDOS攻击风险

9）、安全日志，管理操作需要记录日志。

10）、业务逻辑安全，除了基础的安全之外，还要考虑接口业务逻辑上的安全设计是否合理，是否可能被绕过；重点关注登陆、忘记密码、重置密码等高危操作。

11）、WebServer配置安全，如果是web服务，需要考虑容器的安全配置，可使用工具扫描

12）、源码安全，测试过程中结合接口源码，覆盖安全功能点，主要关注自研接口代码。

### 如果大批量用户刷接口，怎么处理？
一、直接拒绝访问
二、返回“操作频繁”的错误提示
三、验证码


### mysql 的索引种类以及用法？

如大家所知道的，Mysql目前主要有以下几种索引类型：FULLTEXT，HASH，BTREE，RTREE。

FULLTEXT 即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE INDEX创建FULLTEXT索引，要比先为一张表建立FULLTEXT然后再将数据写入的速度快很多。

HASH

Hash这个词，可以说，自打我们开始码的那一天起，就开始不停地见到和使用到了。其实，hash就是一种（key=>value）形式的键值对，如数学中的函数映射，允许多个key对应相同的value，但不允许一个key对应多个value。正是由于这个特性，hash很适合做索引，为某一列或几列建立hash索引，就会利用这一列或几列的值通过一定的算法计算出一个hash值，对应一行或几行数据（这里在概念上和函数映射有区别，不要混淆）。在java语言中，每个类都有自己的hashcode()方法，没有显示定义的都继承自object类，该方法使得每一个对象都是唯一的，在进行对象间equal比较，和序列化传输中起到了很重要的作用。hash的生成方法有很多种，足可以保证hash码的唯一性，例如在MongoDB中，每一个document都有系统为其生成的唯一的objectID（包含时间戳，主机散列值，进程PID，和自增ID）也是一种hash的表现。额，我好像扯远了-_-!

由于hash索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。那为什么还需要其他的树形索引呢？
每次查询时都要遍历hash表，直到找到对应的hash值，如（4），数据量大了之后，hash表也会变得庞大起来，性能下降，遍历耗时增加。

BTREE

BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中，相信学过数据结构的童鞋都对当初学习二叉树这种数据结构的经历记忆犹新，反正愚安我当时为了软考可是被这玩意儿好好地折腾了一番，不过那次考试好像没怎么考这个。如二叉树一样，每次查询都是从树的入口root开始，依次遍历node，获取leaf。

BTREE在MyISAM里的形式和Innodb稍有不同

在 Innodb里，有两种形态：一是primary key形态，其leaf node里存放的是数据，而且不仅存放了索引键的数据，还存放了其他字段的数据。二是secondary index，其leaf node和普通的BTREE差不多，只是还存放了指向主键的信息.

而在MyISAM里，主键和其他的并没有太大区别。不过和Innodb不太一样的地方是在MyISAM里，leaf node里存放的不是主键的信息，而是指向数据文件里的对应数据行的信息.

RTREE
RTREE在mysql很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。
相对于BTREE，RTREE的优势在于范围查找.

各种索引的使用情况

（1）对于BTREE这种Mysql默认的索引类型，具有普遍的适用性

（2）由于FULLTEXT对中文支持不是很好，在没有插件的情况下，最好不要使用。其实，一些小的博客应用，只需要在数据采集时，为其建立关键字列表，通过关键字索引，也是一个不错的方法，至少愚安我是经常这么做的。

（3）对于一些搜索引擎级别的应用来说，FULLTEXT同样不是一个好的处理方法，Mysql的全文索引建立的文件还是比较大的，而且效率不是很高，即便是使用了中文分词插件，对中文分词支持也只是一般。真要碰到这种问题，Apache的Lucene或许是你的选择。

（4）正是因为hash表在处理较小数据量时具有无可比拟的素的优势，所以hash索引很适合做缓存（内存数据库）。如mysql数据库的内存版本Memsql，使用量很广泛的缓存工具Mencached，NoSql数据库redis等，都使用了hash索引这种形式。当然，不想学习这些东西的话Mysql的MEMORY引擎也是可以满足这种需求的。

（5）至于RTREE，愚安我至今还没有使用过，它具体怎么样，我就不知道了。有RTREE使用经历的同学，到时可以交流下！


### Java 和 mybatis 如何防止 sql 注入？

### java 防止并发的措施？

### 原子类的实现原理？

### 线程池原理

### JVM 内存结构？垃圾回收相关？jvm 垃圾回收的入口？


### hashmap 以及 concurrenthashmap 的实现以及使用问题？

### 如果cpu占用率较高，如何分析出哪个进程？top命令进行查看；如何分析出是java的哪个线程呢？


java后端面试-vipkid面试总结
2018年09月29日 16:18:41 softbreezee 阅读数：66
一面：

### 1、说说项目架构的过程
### 
### 2、如果xml充当数据库，dao层的实现
### 
### 3、依赖注入的实现方式
### 
### 4、写一个排序算法
### 
### 5、知道哪些设计模式，工厂模式有什么用
### 
### 6、谈谈怎么保证并发安全，谈到了不可变对象，同步容器，并发容器，堆栈封闭
### 
### 7、谈谈对象创建的过程，变量对象是如何存储的
### 
### 8、谈谈微服务
微服务的优点
可以实现真正的敏捷。可以高速部署上线、可以具有很好的伸缩性、可以具有很好的扩展性。
微服务还更easy形成积木。可以在产品的开发中，越跑越快。

微服务的挑战

微服务对基础服务设施的挑战。既然微服务的职责单一，那么就将要面对一个站点可能有成千上万个微服务。
那么怎样管理好微服务、以及微服务之间怎样实现高速的通信、怎样让开发人员很方便的调用微服务。怎样建立完好的公布系统，可以实现高速上线。
当然这些问题。眼下已经有许多框架来解决。

微服务对开发人员的挑战。微服务的团队一般按业务划分的，一个人负责一个服务或者一个人负责多个服务。那么微服务开发人员。须要是一个全栈开发project师，须要具备多种语言编程的能力、须要前后端的开发能力、须要运维知识、DBA知识。尽管眼下技术发展很快，并且越来越简单，可是成为一名全栈开发project师。还是具有不少的挑战

### 9、谈谈http，谈到了websocket 
WebSocket是HTML5中的协议，也是基于TCP协议的，和HTTP协议是并存的两种协议。
WebSocket与Socket的关系总结：Socket是传输控制层接口，WebSocket是应用层协议。

WebSocket与HTTP的关系 
相同点
1. 都是一样基于TCP的，都是可靠性传输协议。
2. 都是应用层协议。
不同点
 1. WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息。HTTP是单向的。
 2. WebSocket是需要浏览器和服务器握手进行建立连接的。而http是浏览器发起向服务器的连接，服务器预先并不知道这个连接。

联系
WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的。
总结：
在WebSocket中，只需要服务器和浏览器通过HTTP协议进行一个握手的动作，然后单独建立一条TCP的通信通道进行数据的传送。 

WebSocket连接的过程是：
首先，客户端发起http请求，经过3次握手后，建立起TCP连接；http请求里存放WebSocket支持的版本号等信息，如：Upgrade、Connection、WebSocket-Version等；
然后，服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据；
最后，客户端收到连接成功的消息后，开始借助于TCP传输信道进行全双工通信。

10、了解longpoll么

 

二面

1、写代码，一道算法题，没有出来

2、谈谈微服务

3、谈谈mysql和redis在什么场景下使用‘

4、redis为什么设计成为单线程，单线程和多线程那个更好

5、谈谈bio和nio

6、谈谈同步io和异步io’

VIPKID Java工程师一面
2018年07月16日 09:04:21 牛客网 阅读数：379
6/25做的笔试。

6/25做的笔试。

线程的创建方式？

线程让步（yield，一时没想起来）

守护线程的作用？

IO操作有哪些类？

异常体系？

char和varchar的区别？

### get 和post的区别
好了，现在你知道，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 
GET和POST还有一个重大区别，简单的说：
GET产生一个TCP数据包；POST产生两个TCP数据包。

长的说：
对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

### session和cookie的区别？
应用场景
登录网站，今输入用户名密码登录了，第二天再打开很多情况下就直接打开了。这个时候用到的一个机制就是cookie。
session一个场景是购物车，添加了商品之后客户端处可以知道添加了哪些商品，而服务器端如何判别呢，所以也需要存储一些信息就用到了session。

区别
存储数据量方面：session 能够存储任意的 java 对象，cookie 只能存储 String 类型的对象
一个在客户端一个在服务端。因Cookie在客户端所以可以编辑伪造，不是十分安全。
Session过多时会消耗服务器资源，大型网站会有专门Session服务器，Cookie存在客户端没问题。
域的支持范围不一样，比方说a.com的Cookie在a.com下都能用，而www.a.com的Session在api.a.com下都不能用，解决这个问题的办法是JSONP或者跨域资源共享。

session多服务器间共享
服务器实现的 session 复制或 session 共享，如 webSphere或 JBOSS 在搭集群时配置实现 session 复制或 session 共享.致命缺点:不好扩展和移植。
利用成熟技术做session复制，如12306使用的gemfire，如常见内存数据库redis或memorycache，虽较普适但依赖第三方.
将 session维护在客户端，利用 cookie，但客户端存在风险数据不安全，且可以存放的数据量较小，所以将session 维护在客户端还要对 session 中的信息加密。
第二种方案和第三种方案的合体，可用gemfire实现 session 复制共享，还可将session 维护在 redis中实现 session 共享，同时可将 session 维护在客户端的cookie 中，但前提是数据要加密。 


### spring创建bean的方式？
一、通过构造函数创建对象。 
二、通过静态方法创建对象。 
三、通过工厂方法创建对象。

springmvc的请求流程？

### restful风格怎么获取URL中的数据，使用哪个注解
RequestMapping
### springMVC中一个全局异常类是什么？
HandlerExceptionResolver

### AOP哪些术语，切入点这个点是指什么？
切入点（Pointcut）：在程序中，切入点一般是一个或多个符合某种规则的方法，用正则表达式来表示，如：expression= "execution(* add*(..))，Pointcut是用来订阅连接点的。
redis持久化的方式？（面试官说还有一个虚拟内存的方式）

redis数据淘汰策略？

tomcat的配置可以配置哪些信息？

git回滚代码？

linux查看端口使用哪个命令？



介绍一下redis和mongodb的各自的应用场景。
首先我们这个项目中有两种应用场景：
场景一：要求TPS（不知道的右转百度）特别高的，比如我们项目有一个点赞的功能，这个点赞的功能促发频率特别高，而且并发量也会特别大，但是它的数据量不会特别大。基于这种情况下，我们采用redis来实现点赞功能。
场景二：项目中涉及评论的内容，而且这个评论表的数据后期会非常大（海量的数据），最后在数据量非常大的情况下还要求比较复杂的查询。基于上述这些情况，我们采用mongodb作为评论表存储数据库。