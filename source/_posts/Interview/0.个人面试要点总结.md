---
abbrlink: '0'
---
# 储备要点
### 发展方向
程序员-架构师-Team Leader（Project Manager）-技术总监
### java
#### servlet执行流程
客户端发出http请求，web服务器将请求转发到servlet容器，servlet容器解析url并根据web.xml找到相对应的servlet，并将request、response对象传递给找到的servlet，servlet根据request就可以知道是谁发出的请求，请求信息及其他信息，当servlet处理完业务逻辑后会将信息放入到response并响应到客户端。
#### Java设计模式思想
（单列模式，工厂模式，策略模式，共23种设计模式）
​	
### spring 核心
#### aop
b) AOP：面向切面编程，主要是管理系统层的业务，比如日志，权限，事物等。AOP是将封装好的对象剖开，找出其中对多个对象产生影响的公共行为，并将其封装为一个可重用的模块，这个模块被命名为切面（aspect），切面将那些与业务逻辑无关，却被业务模块共同调用的逻辑提取并封装起来，减少了系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。
#### ioc
a) IOC：IOC控制反转主要强调的是程序之间的关系是由容器控制的，容器控制对象，控制了对外部资源的获取。而反转即为，在传统的编程中都是由我们创建对象获取依赖对象，而在IOC中是容器帮我们创建对象并注入依赖对象，正是容器帮我们查找和注入对象，对象是被获取，所以叫反转。
#### 使用Spring有什么好处
◆Spring能有效地组织你的中间层对象,无论你是否选择使用了EJB。如果你仅仅使用了Struts或其他的包含了J2EE特有APIs的framework，你会发现Spring关注了遗留下的问题，。
◆Spring能消除在许多工程上对Singleton的过多使用。根据我的经验，这是一个主要的问题，它减少了系统的可测试性和面向对象特性。
◆Spring能消除使用各种各样格式的属性定制文件的需要,在整个应用和工程中，可通过一种 一致的方法来进行配置。曾经感到迷惑，一个特定类要查找迷幻般的属性关键字或系统属性,为此不得不读Javadoc乃至源编码吗？有了Spring，你可 很简单地看到类的JavaBean属性。倒置控制的使用(在下面讨论)帮助完成这种简化。
◆Spring能通过接口而不是类促进好的编程习惯，减少编程代价到几乎为零。
◆Spring被设计为让使用它创建的应用尽可能少的依赖于他的APIs。在Spring应用中的大多数业务对象没有依赖于Spring。
◆使用Spring构建的应用程序易于单元测试。
◆Spring能使EJB的使用成为一个实现选择,而不是应用架构的必然选择。你能选择用POJOs或local EJBs来实现业务接口，却不会影响调用代码。
◆Spring帮助你解决许多问题而无需使用EJB。Spring能提供一种EJB的替换物，它们适于许多web应用。例如,Spring能使用AOP提供声明性事务而不通过使用EJB容器，如果你仅仅需要与单个的数据库打交道，甚至不需要JTA实现。
■Spring为数据存取提供了一致的框架,不论是使用JDBC或O/R mapping产品（如Hibernate）。
Spring确实使你能通过最简单可行的解决办法解决你的问题。这些特性是有很大价值的。
总结起来，Spring有如下优点：
◆低侵入式设计，代码污染极低
◆ 独立于各种应用服务器，可以真正实现Write Once,Run Anywhere的承诺
◆Spring的DI机制降低了业务对象替换的复杂性
◆Spring并不完全依赖于Spring，开发者可自由选用Spring框架的部分或全部
#### 事物的理解
a) 事物具有原子性，一致性，持久性，隔离性
b) 原子性：是指在一个事物中，要么全部执行成功，要么全部失败回滚。
c) 一致性：事物执行之前和执行之后都处于一致性状态
d) 持久性：事物多数据的操作是永久性
e) 隔离性：当一个事物正在对数据进行操作时，另一个事物不可以对数据进行操作，也就是多个并发事物之间相互隔离。
### springmvc
#### Spring MVC Framework有这样一些特点
1。它是基于组件技术的.全部的应用对象,无论控制器和视图,还是业务对象之类的都是java组件.并且和Spring提供的其他基础结构紧密集成.
2。不依赖于Servlet API(目标虽是如此,但是在实现的时候确实是依赖于Servlet的)
3。可以任意使用各种视图技术,而不仅仅局限于JSP
4。支持各种请求资源的映射策略
5。它应是易于扩展的
#### springMVC的执行流程
springMVC是由dispatchservlet为核心的分层控制框架。首先客户端发出一个请求，web服务器解析请求url并去匹配dispatchservlet的映射url，如果匹配上就将这个请求放入到dispatchservlet，dispatchservlet根据mapping映射配置去寻找相对应的handel，然后把处理权交给找到的handel，handel封装了处理业务逻辑的代码，当handel处理完后会返回一个逻辑视图modelandview给dispatchservlet，此时的modelandview是一个逻辑视图不是一个正式视图，所以dispatchservlet会通过viewresource视图资源去解析modelandview，然后将解析后的参数放到view中返回到客户端并展现。
#### 如果你也用过struts2.简单介绍下springMVC和struts2的区别有哪些
1. springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。
2. springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。
3. Struts采用值栈存储请求和响应的数据，通过OGNL存取数据， springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。
### struts
#### Struts1与Struts2的区别  
简单来说二者的区别是：一个是Stuts1 ，一个是Stuts2，这是最大的区别，技术方面，Stuts1有个核心控制器，但是只提供了一个接口，也就是execute，还要配置actionform之类的，很麻烦，所以依赖性比较强；而Stuts2是针对拦截器开发的，也就是所谓的AOP思想，可以配置多个action，用起来比较方便，但是因为请求之前的拦截器有一些注入的操作，速度相对Stuts1来说慢一点。
#### Struts1的一些缺点
Struts2既然是从Struts1发展而来，但实际上Struts2与Struts1在框架的设计思想上面还是有很大的区别，Struts2是以WebWork的设计思想为核心，为什么Struts2不沿用Struts1的设计思想，毕竟Struts1在目前的企业应用中还是有非常大的市场在的，那么，来看下Struts1的一些缺点吧：
​        1）支持的表现层技术单一
​        2）与Servlet API严重耦合，这点可以从Action的Execute的方法声明里面就可以看的出来
​        3）代码依赖Struts1 API，有侵入性，这点可以从写Action类和FormBean的时候看的出来，Action必须实现Struts的Action类
​        而Struts2之所以以WebWork的设计思想为其核心，一点就是最近WebWork的上升势头，再就是WebWork没有Struts1上面的那些缺点，更符合MVC的设计思想，也更利于代码的复用。
​        基于以上介绍可以看的出，Struts2体系结构与Struts1的体系结构有很大的差别，Struts1是使用ActionServlet做为其中心处理器，Struts2则使用一个拦截器（FilterDispatcher）做为其中心处理器，这样做的一个好处就是将Action类和Servlet API进行了分离。
​		
#### Struts2工作流程
a) 客户端发出一个请求到servlet容器
b) 请求经过一些列过滤被filterdispatcher调用，filterdispatch通过actionMapper去找相对应的action。
c) Actionmapper找到对应的action返回给filterdispatch，dispatch把处理权交给actionproxy
d) Actionproxy通过配置文件找到对应的action类
e) Actionproxy创建一个actionIinvocation的实例处理业务逻辑
f) 一旦action处理完毕，actioninvocation负责根据stuts.xml的配置找到对应的返回结果。返回结果通常是jsp页面。

### 架构
#### 高并发处理
高并发处理  a) 了解一点高并发性问题，比如一W人抢一张票时，如何保证票在没买走的情况下所有人都能看见这张票，显然是不能用同步机制，因为synchronize是锁同步一次只能一个人进行。这时候可以用到锁机制，采用乐观锁可以解决这个问题。乐观锁的简单意思是在不锁定表的情况下，利用业务的控制来解决并发问题，这样即保证数据的可读性，又保证保存数据的排他性，保证性能的同时解决了并发带来的脏读数据问题。 
#### SSM优缺点、使用场景
1. Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。
2. Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。
3. Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。
4. 总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。
#### 高可用
高可用（High Availability），是当一台服务器停止服务后，对于业务及用户毫无影响。 停止服务的原因可能由于网卡、路由器、机房、CPU负载过高、内存溢出、自然灾害等不可预期的原因导致，在很多时候也称单点问题。
（1）解决单点问题主要有2种方式：
主备方式
这种通常是一台主机、一台或多台备机，在正常情况下主机对外提供服务，并把数据同步到备机，当主机宕机后，备机立刻开始服务。
Redis HA中使用比较多的是keepalived，它使主机备机对外提供同一个虚拟IP，客户端通过虚拟IP进行数据操作，正常期间主机一直对外提供服务，宕机后VIP自动漂移到备机上。
优点是对客户端毫无影响，仍然通过VIP操作。
缺点也很明显，在绝大多数时间内备机是一直没使用，被浪费着的。
主从方式
这种采取一主多从的办法，主从之间进行数据同步。 当Master宕机后，通过选举算法(Paxos、Raft)从slave中选举出新Master继续对外提供服务，主机恢复后以slave的身份重新加入。
主从另一个目的是进行读写分离，这是当单机读写压力过高的一种通用型解决方案。 其主机的角色只提供写操作或少量的读，把多余读请求通过负载均衡算法分流到单个或多个slave服务器上。
缺点是主机宕机后，Slave虽然被选举成新Master了，但对外提供的IP服务地址却发生变化了，意味着会影响到客户端。 解决这种情况需要一些额外的工作，在当主机地址发生变化后及时通知到客户端，客户端收到新地址后，使用新地址继续发送新请求。
（2）数据同步
无论是主备还是主从都牵扯到数据同步的问题，这也分2种情况：
同步方式：当主机收到客户端写操作后，以同步方式把数据同步到从机上，当从机也成功写入后，主机才返回给客户端成功，也称数据强一致性。 很显然这种方式性能会降低不少，当从机很多时，可以不用每台都同步，主机同步某一台从机后，从机再把数据分发同步到其他从机上，这样提高主机性能分担同步压力。 在redis中是支持这杨配置的，一台master，一台slave，同时这台salve又作为其他slave的master。
异步方式：主机接收到写操作后，直接返回成功，然后在后台用异步方式把数据同步到从机上。 这种同步性能比较好，但无法保证数据的完整性，比如在异步同步过程中主机突然宕机了，也称这种方式为数据弱一致性。
Redis主从同步采用的是异步方式，因此会有少量丢数据的危险。还有种弱一致性的特例叫最终一致性，这块详细内容可参见CAP原理及一致性模型。
（3）方案选择
keepalived方案配置简单、人力成本小，在数据量少、压力小的情况下推荐使用。 如果数据量比较大，不希望过多浪费机器，还希望在宕机后，做一些自定义的措施，比如报警、记日志、数据迁移等操作，推荐使用主从方式，因为和主从搭配的一般还有个管理监控中心。
宕机通知这块，可以集成到客户端组件上，也可单独抽离出来。 Redis官方Sentinel支持故障自动转移、通知等，详情见低成本高可用方案设计(四)。
逻辑图：
#### 分布式集群时代
当缓存数据量不断增加时，单机内存不够使用，需要把数据切分不同部分，分布到多台服务器上。
可在客户端对数据进行分片，数据分片算法详见C#一致性Hash详解、C#之虚拟桶分片。
逻辑图：
这里写图片描述
大规模分布式集群时代
当数据量持续增加时，应用可根据不同场景下的业务申请对应的分布式集群。 这块最关键的是缓存治理这块，其中最重要的部分是加入了代理服务。 应用通过代理访问真实的Redis服务器进行读写，这样做的好处是：
避免越来越多的客户端直接访问Redis服务器难以管理，而造成风险。
在代理这一层可以做对应的安全措施，比如限流、授权、分片。
避免客户端越来越多的逻辑代码，不但臃肿升级还比较麻烦。
代理这层无状态的，可任意扩展节点，对于客户端来说，访问代理跟访问单机Redis一样。
目前楼主公司使用的是客户端组件和代理两种方案并存，因为通过代理会影响一定的性能。 代理这块对应的方案实现有Twitter的Twemproxy和豌豆荚的codis。
逻辑图：
#### 分布式
分布式(distributed), 是当业务量、数据量增加时，可以通过任意增加减少服务器数量来解决问题。
集群时代
至少部署两台Redis服务器构成一个小的集群，主要有2个目的：
高可用性：在主机挂掉后，自动故障转移，使前端服务对用户无影响。
读写分离：将主机读压力分流到从机上。
可在客户端组件上实现负载均衡，根据不同服务器的运行情况，分担不同比例的读请求压力。
逻辑图：
### springboot
#### Spring Boot、Spring MVC 和 Spring 有什么区别
SpringFrame
SpringFramework 最重要的特征是依赖注入。所有 SpringModules 不是依赖注入就是 IOC 控制反转。
当我们恰当的使用 DI 或者是 IOC 的时候，我们可以开发松耦合应用。松耦合应用的单元测试可以很容易的进行。
SpringMVC
Spring MVC 提供了一种分离式的方法来开发 Web 应用。通过运用像 DispatcherServelet，MoudlAndView 和 ViewResolver 等一些简单的概念，开发 Web 应用将会变的非常简单。
SpringBoot
Spring 和 SpringMVC 的问题在于需要配置大量的参数。
### hibernate
#### hibernate的核心思想
a) Hibernate的核心思想是ROM对象关系映射机制。它是将表与表之间的操作映射成对象与对象之间的操作。也就是从数据库中提取的信息会自动按照你设置的映射要求封装成特定的对象。所以hibernate就是通过将数据表实体类的映射，使得对对象的修改对应数据行的修改。

### mybatis
#### 对mybatis的理解
1. mybatis配置
2. SqlMapConfig.xml，此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息。
3. mapper.xml文件即sql映射文件，文件中配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载。
4. 通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂
5. 由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行。
6. mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行器。
7. Mapped Statement也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id。
8. Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数。
9. Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql后将输出结果映射至java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程。
#### Mybatis是如何进行分页的？分页插件的原理是什么？
Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。
分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。
举例：select * from student，拦截sql后重写为：select t.* from （select * from student）t limit 0，10
#### 为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？
答：Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。

### h5
#### 对ajax的理解  
a) Ajax为异步请求，即局部刷新技术，在传统的页面中，用户需要点击按钮或者事件触发请求，到刷新页面，而异步技术为不需要点击即可触发事件，这样使得用户体验感增强，比如商城购物车的异步加载，当你点击商品时无需请求后台而直接动态修改参数。

### springcloud
### db
#### 数据库优化 
a) 选择合适的字段，比如邮箱字段可以设为char（6），尽量把字段设置为not null，这样查询的时候数据库就不需要比较null值  
b) 使用关联查询（ left join on）查询代替子查询  
c) 使用union联合查询手动创建临时表  d) 开启事务，当数据库执行多条语句出现错误时，事务会回滚，可以维护数据库的完整性  
e) 使用外键，事务可以维护数据的完整性但是它却不能保证数据的关联性，使用外键可以保证数据的关联性  
f) 使用索引，索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快的多的速度检索特定的行，特别是对于max，min，order by查询时，效果更明显  g) 优化的查询语句，绝大多数情况下，使用索引可以提高查询的速度，但如果sql语句使用不恰当的话，索引无法发挥它的特性。 

### Redis
#### 使用Redis有哪些好处
(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
(2) 支持丰富数据类型，支持string，list，set，sorted set，hash
(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行
(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除
#### Redis相比Memcached有哪些优势
(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型
(2) redis的速度比memcached快很多
(3) redis可以持久化其数据
#### Redis常见性能问题和解决方案
(1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件
(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次
(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内
(4) 尽量避免在压力很大的主库上增加从库
(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <- Slave3…
这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。
#### Redis 最适合的场景
Redis最适合所有数据in-momory的场景，虽然Redis也提供持久化功能，但实际更多的是一个disk-backed的功能，跟传统意义上的持久化有比较大的差别，那么可能大家就会有疑问，似乎Redis更像一个加强版的Memcached，那么何时使用Memcached,何时使用Redis呢?
如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点：
1 、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
2 、Redis支持数据的备份，即master-slave模式的数据备份。
3 、Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。

（1）、会话缓存（Session Cache）
（2）、全页缓存（FPC）
（3）、队列
（4），排行榜/计数器
（5）、发布/订阅
### MongoDB


### linux
tail命令
用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。
常用参数：
-f 循环读取（常用于查看递增的日志文件）
-n<行数> 显示行数（从后向前）
chmod命令
用于改变linux系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。 
实例：
（1）增加文件t.log所有用户可执行权限
chmod a+x t.log
grep命令
强大的文本搜索命令，grep(Global Regular Expression Print)全局正则表达式搜索
实例：
（1）查找指定进程
ps -ef | grep svn
ps命令
ps(process status)，用来查看当前运行的进程状态，一次性查看，如果需要动态连续结果使用top
linux上进程有5种状态:
top命令
显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等
kill命令
发送指定的信号到相应进程。不指定型号将发送SIGTERM（15）终止指定进程。如果任无法终止该程序可用“-KILL” 参数，其发送的信号为SIGKILL(9) ，将强制结束进程，使用ps命令或者jobs 命令可以查看进程号。root用户将影响用户的进程，非root用户只能影响自己的进程。

### tomcat
Tomcat服务器优化
（内存，并发连接数，缓存）
a) 内存优化：主要是对Tomcat启动参数进行优化，我们可以在Tomcat启动脚本中修改它的最大内存数等等。
b) 线程数优化：Tomcat的并发连接参数，主要在Tomcat配置文件中server.xml中配置，比如修改最小空闲连接线程数，用于提高系统处理性能等等。
c) 优化缓存：打开压缩功能，修改参数，比如压缩的输出内容大小默认为2KB，可以适当的修改。

### 分布式架构的定义
服务组件是分布在网络计算机上  
组件之间通过消息传递   