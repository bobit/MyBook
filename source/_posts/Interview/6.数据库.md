---
title: 数据库、缓存、算法相关
toc: true
typora-copy-images-to: ../../gitbooks/static/images/
mathjax: true
abbrlink: 368a7248
tags:
  - Interview
categories:
  - Interview
date: 2017-12-28 17:11:22
---



## 数据库

### 数据库优化 

a) 选择合适的字段，比如邮箱字段可以设为char（6），尽量把字段设置为not null，这样查询的时候数据库就不需要比较null值  
b) 使用关联查询（ left join on）查询代替子查询  
c) 使用union联合查询手动创建临时表  d) 开启事务，当数据库执行多条语句出现错误时，事务会回滚，可以维护数据库的完整性  
e) 使用外键，事务可以维护数据的完整性但是它却不能保证数据的关联性，使用外键可以保证数据的关联性  
f) 使用索引，索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快的多的速度检索特定的行，特别是对于max，min，order by查询时，效果更明显  g) 优化的查询语句，绝大多数情况下，使用索引可以提高查询的速度，但如果sql语句使用不恰当的话，索引无法发挥它的特性。 



### SQL存储过程详细解析 

- 存储过程(stored procedure)是一组为了完成特定功能的SQL语句集合，经编译后存储在服务器端的，利用存储过程可以加速SQL语句的执行。
- 存储过程分为系统存储过程和自定义存储过程。
- 系统存储过程在master数据库中，但是在其他的数据库中可以直接调用，并且在调用时不必在存储过程前加上数据库名，因为在创建一个新数据库时，系统存储过程在新的数据库中会自动创建
- 自定义存储过程，由用户创建并能完成某一特定功能的存储过程，存储过程既可以有参数又有返回值，但是它与函数不同，存储过程的返回值只是指明执行是否成功，并不能像函数那样被直接调用，只能利用execute来执行存储过程。

### 存储过程的优点 

- 提高应用程序的通用性和可移植性：存储过程创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。并且数据库专业人员可以随时对存储过程进行修改，且对程序源代码没有影响，这样就极大的提高了程序的可移植性。
- 可以更有效的管理用户操作数据库的权限：在Sql Server数据库中，系统管理员可以通过对执行某一存储过程的权限进行限制，从而实现对相应的数据访问进行控制，避免非授权用户对数据库的访问，保证数据的安全。
- 可以提高SQL的速度，存储过程是编译过的，如果某一个操作包含大量的SQL代码或分别被执行多次，那么使用存储过程比直接使用单条SQL语句执行速度快的多。
- 减轻服务器的负担：当用户的操作是针对数据库对象的操作时，如果使用单条调用的方式，那么网络上还必须传输大量的SQL语句，如果使用存储过程，则直接发送过程的调用命令即可，降低了网络的负担。

### 存储过程的缺点：

- 如果更改范围大到需要对输入存储过程的参数进行更改，或者要更改由其返回的数据，则您仍需要更新程序集中的代码以添加参数、更新 GetValue() 调用，等等，这时候估计比较繁琐了。
- 可移植性差
  由于存储过程将应用程序绑定到 SQL Server，因此使用存储过程封装业务逻辑将限制应用程序的可移植性。如果应用程序的可移植性在您的环境中非常重要，则将业务逻辑封装在不特定于 RDBMS 的中间层中可能是一个更佳的选择。 
- 大量采用存储过程进行业务逻辑的开发致命的缺点是很多存储过程不支持面向对象的设计，无法采用面向对象的方式将业务逻辑进行封装，从而无法形成通用的可支持复用的业务逻辑框架。
- 代码可读性差,相当难维护.



### 数据库的四大特征，数据库的隔离级别？

数据库的四大特征：

（1）原子性（Atomicity）
原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。
（2）一致性（Consistency）
一个事务执行之前和执行之后都必须处于一致性状态。
（3）隔离性（Isolation）
隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
4）持久性（Durability）
持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的。

数据库的隔离级别：

1）Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。
2）Repeatable read (可重复读)：可避免脏读、不可重复读的发生。
3）Read committed (读已提交)：可避免脏读的发生。
4）Read uncommitted (读未提交)：最低级别，任何情况都无法保证。

](https://mp.weixin.qq.com/s/eFFgCoi70hAtLH2rHV6dag)

### 数据库设计中常讲的三范式是指什么？

1）第一范式1NF(域的原子性)
如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式
2）第二范式2NF(表中除主键外的字段都完全依赖主键)
第二范式是在第一范式基础上建立的。第二范式有两个重点:(1)表中必须有主键；(2)其他非主属性必须完全依赖主键，不能只依赖主键的一部分（主要针对联合主键而言）。
3）第三范式3NF（表中除主键外的字段都完全直接依赖，不能是传递依赖）
不能是传递依赖，即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。第二范式和第三范式区分的关键点：2NF：非主键列是否完全依赖于主键，还是依赖于主键的一部分；3NF：非主键列是直接依赖于主键，还是直接依赖于非主键列。

## 缓存



### Redis

### Redis和Memcache区别对比？如何选择这两个技术？

区别：
1） Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等。
2）Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。
3）虚拟内存--Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘
4）过期策略--memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire 设定，例如expire name 10
5）分布式--设定memcache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从
6）存储数据安全--memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）
7）灾难恢复--memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复
8）Redis支持数据的备份，即master-slave模式的数据备份。

选型：
若是简单的存取key-value这样的数据用memcache好一些
若是要支持数据持久化，多数据类型(如集合、散列之类的)，用列表类型做队列之类的高级应用，就用redis

#### Redis相比Memcached有哪些优势

(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型
(2) redis的速度比memcached快很多
(3) redis可以持久化其数据

### Redis的持久化机制是什么？各自的优缺点？

redis提供两种持久化机制RDB和AOF机制
1）RDB持久化方式：
是指用数据集快照的方式记录redis数据库的所有键值对。
优点：
1.只有一个文件dump.rdb，方便持久化。
2.容灾性好，一个文件可以保存到安全的磁盘。
3.性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化。
4.相对于数据集大时，比AOF的启动效率更高。
缺点：
1.数据安全性低。
2）AOF持久化方式：
是指所有的命令行记录以redis命令请求协议的格式保存为aof文件。
优点：
1.数据安全，aof持久化可以配置appendfsync属性，有always，每进行一次命令操作就记录到aof文件中一次。
2.通过append模式写文件，即使中途服务器宕机，可以通过redis-check-aof工具解决数据一致性问题。
3.AOF机制的rewrite模式。
缺点：
1.文件会比RDB形式的文件大。
2.数据集大的时候，比rdb启动效率低。

#### 使用Redis有哪些好处

(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
(2) 支持丰富数据类型，支持string，list，set，sorted set，hash
(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行
(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除



#### Redis常见性能问题和解决方案

(1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件
(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次
(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内
(4) 尽量避免在压力很大的主库上增加从库
(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <- Slave3…
这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。

Redis 最适合的场景

Redis最适合所有数据in-momory的场景，虽然Redis也提供持久化功能，但实际更多的是一个disk-backed的功能，跟传统意义上的持久化有比较大的差别，那么可能大家就会有疑问，似乎Redis更像一个加强版的Memcached，那么何时使用Memcached,何时使用Redis呢?
如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点：
1 、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
2 、Redis支持数据的备份，即master-slave模式的数据备份。
3 、Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。

（1）、会话缓存（Session Cache）
（2）、全页缓存（FPC）
（3）、队列
（4），排行榜/计数器
（5）、发布/订阅

#### Redis几种数据结构的应用场景

###### String  

###### 常用命令：  

 除了get、set、incr、decr mget等操作外，Redis还提供了下面一些操作：  
 获取字符串长度  
 往字符串append内容  
 设置和获取字符串的某一段内容  
 设置及获取字符串的某一位（bit）  
 批量设置一系列字符串的内容  

###### 应用场景：  

String是最常用的一种数据类型，普通的key/value存储都可以归为此类，value其实不仅是String，  也可以是数字：比如想知道什么时候封锁一个IP地址(访问超过几次)。INCRBY命令让这些变得很容易，通过原子递增保持计数。  

###### 实现方式：  

m,decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。  

###### hash

###### 常用命令：  

hget,hset,hgetall 等。  
应用场景：  
我们简单举个实例来描述下Hash的应用场景，比如我们要存储一个用户信息对象数据，包含以下信息：  
 用户ID，为查找的key，  
存储的value用户对象包含姓名name，年龄age，生日birthday 等信息，  
如果用普通的key/value结构来存储，主要有以下2种存储方式：  
第一种方式将用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储，  
如：set u001 "李三,18,20010101"  
 这种方式的缺点是，增加了序列化/反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。  
 第二种方法是这个用户信息对象有多少成员就存成多少个key-value对儿，用用户ID+对应属性的名称作为唯一标识来取得对应属性的值，  
 如：mset user:001:name "李三 "user:001:age18 user:001:birthday "20010101"  
虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。  
那么Redis提供的Hash很好的解决了这个问题，Redis的Hash实际是内部存储的Value为一个HashMap，  
并提供了直接存取这个Map成员的接口，  
  如：hmset user:001 name "李三" age 18 birthday "20010101"     
 也就是说，Key仍然是用户ID,value是一个Map，这个Map的key是成员的属性名，value是属性值，   这样对数据的修改和存取都可以直接通过其内部Map的Key(Redis里称内部Map的key为field), 也就是通过 key(用户ID) + field(属性标签) 操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。很好的解决了问题。  
这里同时需要注意，Redis提供了接口(hgetall)可以直接取到全部的属性数据,但是如果内部Map的成员很多，那么涉及到遍历整个内部Map的操作，由于Redis单线程模型的缘故，这个遍历操作可能会比较耗时，而另其它客户端的请求完全不响应，这点需要格外注意。  

实现方式：  

上面已经说到Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap,当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。

###### list

###### 常用命令：  

 lpush,rpush,lpop,rpop,lrange,BLPOP(阻塞版)等。  

###### 应用场景：  

 Redis list的应用场景非常多，也是Redis最重要的数据结构之一。  
我们可以轻松地实现最新消息排行等功能。  
Lists的另一个应用就是消息队列，可以利用Lists的PUSH操作，将任务存在Lists中，然后工作线程再用POP操作将任务取出进行执行。  

###### 实现方式：  

 Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。  
RPOPLPUSH source destination  
 命令 RPOPLPUSH 在一个原子时间内，执行以下两个动作：  
将列表 source 中的最后一个元素(尾元素)弹出，并返回给客户端。  
将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素。  
如果 source 和 destination 相同，则列表中的表尾元素被移动到表头，并返回该元素，可以把这种特殊情况视作列表的旋转(rotation)操作。  
一个典型的例子就是服务器的监控程序：它们需要在尽可能短的时间内，并行地检查一组网站，确保它们的可访问性。  
 redis.lpush "downstream_ips", "192.168.0.10"  
 redis.lpush "downstream_ips", "192.168.0.11"  
redis.lpush "downstream_ips", "192.168.0.12"  
redis.lpush "downstream_ips", "192.168.0.13"  
Then:  
next_ip = redis.rpoplpush "downstream_ips", "downstream_ips"  
BLPOP  
假设现在有 job 、 command 和 request 三个列表，其中 job 不存在， command 和 request 都持有非空列表。考虑以下命令：  
BLPOP job command request 30  #阻塞30秒，0的话就是无限期阻塞,job列表为空,被跳过,紧接着command 列表的第一个元素被弹出。  
1) "command"                             # 弹出元素所属的列表  
 2) "update system..."                    # 弹出元素所属的值   
为什么要阻塞版本的pop呢，主要是为了避免轮询。举个简单的例子如果我们用list来实现一个工作队列。执行任务的thread可以调用阻塞版本的pop去获取任务这样就可以避免轮询去检查是否有任务存在。当任务来时候工作线程可以立即返回，也可以避免轮询带来的延迟。  

set 

###### 常用命令：  

 sadd,srem,spop,sdiff ,smembers,sunion 等。  

###### 应用场景：  

Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。  
比如在微博应用中，每个人的好友存在一个集合（set）中，这样求两个人的共同好友的操作，可能就只需要用求交集命令即可。  
Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实  

###### 实现方式：  

 set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。  

###### sortedset

###### 使用场景：  

 以某个条件为权重，比如按顶的次数排序.  
 ZREVRANGE命令可以用来按照得分来获取前100名的用户，ZRANK可以用来获取用户排名，非常直接而且操作容易。  
 Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。  
  比如:twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。  
 比如:全班同学成绩的SortedSets，value可以是同学的学号，而score就可以是其考试得分，这样数据插入集合的，就已经进行了天然的排序。  
 另外还可以用Sorted Sets来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。  
 需要精准设定过期时间的应用  
 比如你可以把上面说到的sorted set的score值设置成过期时间的时间戳，那么就可以简单地通过过期时间排序，定时清除过期数据了，不仅是清除Redis中的过期数据，你完全可以把Redis里这个过期时间当成是对数据库中数据的索引，用Redis来找出哪些数据需要过期删除，然后再精准地从数据库中删除相应的记录。  

###### 实现方式：  

  Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。  

###### 发布订阅：

 Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，  
  当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。  
客户端1：subscribe  rain  
客户端2：PUBLISH  rain "my love!!!"  
(integer) 2 代表有几个客户端订阅了这个消息  

###### 事物：

 谁说NoSQL都不支持事务，虽然Redis的Transactions提供的并不是严格的ACID的事务（比如一串用EXEC提交执行的命令，在执行中服务器宕机，那么会有一部分命令执行了，剩下的没执行），但是这个Transactions还是提供了基本的命令打包执行的功能（在服务器不出问题的情况下，可以保证一连串的命令是顺序在一起执行的，中间有会有其它客户端命令插进来执行）。  
 Redis还提供了一个Watch功能，你可以对一个key进行Watch，然后再执行Transactions，在这过程中，如果这个Watched的值进行了修改，那么这个Transactions会发现并拒绝执行。  

```
Session 1  
(1)第1步  
 redis 127.0.0.1:6379> get age  
"10"  
 redis 127.0.0.1:6379> watch age  
OK  
redis 127.0.0.1:6379> multi  
 OK  
 redis 127.0.0.1:6379>  
Session 2  
(2)第2步  
redis 127.0.0.1:6379> set age 30  
OK  
redis 127.0.0.1:6379> get age  
"30"  
redis 127.0.0.1:6379>  

 Session 1     
(3)第3步  
redis 127.0.0.1:6379> set age 20  
QUEUED  
redis 127.0.0.1:6379> exec  
(nil)  
redis 127.0.0.1:6379> get age  
"30"  
redis 127.0.0.1:6379>  
```

第一步，Session 1 还没有来得及对age的值进行修改  
第二步，Session 2 已经将age的值设为30  
第三步，Session 1 希望将age的值设为20，但结果一执行返回是nil，说明执行失败，之后我们再取一下age的值是30，这是由于Session   1中对age加了乐观锁导致的。  

## 算法

### 排序都有哪几种方法？请列举。用JAVA 实现一个快速排序。

排序的方法有：
插入排序（直接插入排序、希尔排序），交换排序（冒泡排序、快速排序），选择排序（直接选择排序、堆排序），归并排序，分配排序（箱排序、基数排序）；
快速排序的伪代码：

//使用快速排序方法对a[ 0 :n- 1 ]排序
从a[ 0 :n- 1 ]中选择一个元素作为middle，该元素为支点；
把余下的元素分割为两段left 和right，使得left 中的元素都小于等于支点，
而right 中的元素都大于等于支点；
递归地使用快速排序方法对left 进行排序；
递归地使用快速排序方法对right 进行排序；
所得结果为left + middle + right。

### 说一下几种常见的排序算法和分别的复杂度

各种排序的主要思路：

#### 冒泡排序

通过交换使相邻的两个数变成小数在前大数在后，这样每次遍历后，最大的数就“沉”到最后面了。重复N次即可以使数组有序。
冒泡排序改进1：在某次遍历中如果没有数据交换，说明整个数组已经有序。因此通过设置标志位来记录此次遍历有无数据交换就可以判断是否要继续循环。
冒泡排序改进2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。

#### 直接插入排序

每次将一个待排序的数据，插入到前面已经排好序的序列之中，直到全部数据插入完成。

#### 直接选择排序

数组分成有序区和无序区，初始时整个数组都是无序区，然后每次从无序区选一个最小的元素直接放到有序区的最后，直到整个数组变有序区。
上面这三种排序都是非常简单的，下面这四种排序略有难度，希望读者能多多实践以加深理解。

#### 希尔排序

先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。由于希尔排序是对相隔若干距离的数据进行直接插入排序，因此可以形象的称希尔排序为“跳着插”

#### 归并排序

当一个数组左边有序，右边也有序，那合并这两个有序数组就完成了排序。如何让左右两边有序了？用递归！这样递归下去，合并上来就是归并排序。

#### 快速排序

“挖坑填数+分治法”，首先令i =L; j = R; 将a[i]挖出形成第一个坑，称a[i]为基准数。然后j--由后向前找比基准数小的数，找到后挖出此数填入前一个坑a[i]中，再i++由前向后找比基准数大的数，找到后也挖出此数填到前一个坑a[j]中。重复进行这种“挖坑填数”直到i==j。再将基准数填入a[i]中，这样i之前的数都比基准数小，i之后的数都比基准数大。因此将数组分成二部分再分别重复上述步骤就完成了排序。

#### 堆排序

堆排序主要思路用张图示来表示更好：

![img](D:/Program Files/Typora)

可见堆排序的难点就在于堆的的插入和删除。

#### 堆的插入

每次插入都是将新数据放在数组最后，而从这个新数据的父结点到根结点必定是一个有序的数列，因此只要将这个新数据插入到这个有序数列中即可。

#### 堆的删除

堆的删除就是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右儿子结点中找最小的，如果父结点比这个最小的子结点还小说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于从根结点开始将一个数据在有序数列中进行“下沉”。

因此，堆的插入和删除非常类似直接插入排序，只不是在二叉树上进行插入过程。所以可以将堆排序形容为“树上插”

### 常用的排序方法的关系

 ![img](D:/Program Files/Typora)

### 各算法的性能比较图

![img](D:/Program Files/Typora)

## 框架

hibernate

#### hibernate的核心思想

a) Hibernate的核心思想是ROM对象关系映射机制。它是将表与表之间的操作映射成对象与对象之间的操作。也就是从数据库中提取的信息会自动按照你设置的映射要求封装成特定的对象。所以hibernate就是通过将数据表实体类的映射，使得对对象的修改对应数据行的修改。

### Mybaits



### Mybaits中#和$区别

1）${}是Properties文件中的变量占位符，它可以用于标签属性值和sql内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。
2）#{}是sql的参数占位符，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值，比如ps.setInt(0, parameterValue)，#{item.name}的取值方式为使用反射从参数对象中获取item对象的name属性值，相当于param.getItem().getName()。

### 对mybatis的理解

1. mybatis配置
2. SqlMapConfig.xml，此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息。
3. mapper.xml文件即sql映射文件，文件中配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载。
4. 通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂
5. 由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行。
6. mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行器。
7. Mapped Statement也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id。
8. Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数。
9. Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql后将输出结果映射至java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程。

### Mybatis是如何进行分页的？分页插件的原理是什么？

Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。
分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。
举例：select * from student，拦截sql后重写为：select t.* from （select * from student）t limit 0，10

### 为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？

答：Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。



### 查询一个字段值有重复的表，要去除重复项，SQL语句怎么写？ 

在SQL语句中加上distinct关键字，如SELECT distinct(name),id FROM table、SELECT distinct name FROM table。

### 分层架构中，Dao层的作用是什么？如果不要DAO层，能不能实现有Dao层时的优点？ 

Dao层又叫数据访问对象层, 封装数据库的底层操作细节如数据库的连接及对数据的CRUD等操作，它不但屏蔽了数据存储最终介质的不同，也屏蔽了具体实现技术的不同。一般在其上还会有Service层来封装业务操作进行进一步的解耦。不用DAO层也能实现Dao层时的优点如自己封装一个类似Dao层功能的数据库操作模板类，可参考Spring的DAO层思想。

BOM结构更改,0316013081更改为0316013081A；0617003329更改为0617003329C

### HibernateDaoSupport,ActionSupport等类中所指的Support，是不是一种设计模式？若是，那说说你对这种设计模式的理解？ 

个人认为用到了IoC模式，即依赖注入，将程序代码中依赖对象的管理交由相应的容器去管理如在配置文件中进行注入配置。

### 对数据库的存储过程熟悉不？对CSS熟悉不？ 

数据库的存储过程（stored procedure）是一组为了完成特定功能的sql 语句集，经编译后存储在数据库，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。从本质上讲触发器也是一种存储过程。存储过程可以调用另一个存储过程，它具有如下的优点：允许标准组件式编程因为它可以多次使用不必重复编写、能够实现较快的执行速度因为它是预编译的比批处理执行更快、能够减少网络流量因为它一次性可执行多个SQL语句、可作为一种安全机制来充分利用，因为系统管理员可对存储过程进行权限限制。 

CSS又叫层叠样式表，是设计网页样式的工具，使用它可更方便的设计和管理网页样式，比普通的HTML标记样式更优秀和方便使用，具体使用在此不多讲。

### Hibernate框架的设计有什么不好的地方？ 

配置麻烦、映射文件可能过于冗余、查询慢、对海量数据无能为力、太对象化限制了查询、级联关系也影响查询速度等。

### 你是怎么样实现分页显示的？具体原理怎么样？Hibernate的setMaxResults和setFirstResult内部是怎么实现分页查询的？ 

实现一个分页组件，可自实现或借用相应框架的实现。原理是求出所查数据总记录数，设置每页要显示的记录数，然后计算每页要显示的第一条记录数，根据每页要显示的记录数和总记录数来求出页数等。 
Hibernate的setMaxResults和setFirstResult内部是通过SQL语句来实现分页查询的，个人观点而已，未查看源代码。

### Struts，Hibernate，Spring等框架，你哪个最熟悉？有没有读过它的源代码？你用过Spring框架的那些功能？ 

最熟悉的是Struts1.x，其次是Hibernate和Spring，读过其中的一些源代码，并没有去读所有的源代码。主要用过的是Spring的IoC和AOP和事务管理等功能。

 

## 参考

[为什么老司机建议MySQL列属性尽量用 NOT NULL 

 