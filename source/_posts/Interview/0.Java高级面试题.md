---
title: Java高级面试题
toc: true
typora-copy-images-to: ../../gitbooks/static/images/
mathjax: true
abbrlink: fd0e5cbc
date: 2017-12-28 17:10:48
tags:
  - Interview
categories:
  - Interview
---





### JMX

Java Management Extensions，Java管理扩展，初步看了些资料，以为是专门管理，监控jvm的一些信息的，特别是visual VM这个监控jvm的东西，还有一个添加JMX连接的时候（我自己想错了，那样的话应该叫jvm Management Extensions），其实他能使得基于java语言开发的程序能被管理，并且是可扩展的。

Jdk以前是通过JVMPI之类来监测Java程序运行中的jvm和系统的一系列情况，现在通过jmx就可以做到，这是通过java.lang.management 包来实现的，这个包是 JMX 在 JDK方面 的一个应用，并不是表示jmx就是一个监控jvm的东西。

我们可以用jmx来监控我们的系统，通过公布API的方式，但是，这里采用监控这个词，也是受了前面的例子的影响，实际上，个人觉得，就可以用jmx来开发我们的系统。

现在的jboss，hibernate，tomcat各种应用都号称实现了JMX规范，将可管理，可调用的MBean注册到MBeanServer中，通过一种类似“web服务”的方式公布出去，并且伴有一个名字，可以通过该名字找到该MBean。并且，这里的MBean是可以被管理的，说到这里又想到了OSGI。

### JMX与Web Service

个人认为，我们实现JMX规范，将东西发布出去，和通过web Service的方式是很类似的，也是可以远程调用的，只是相对的web Service的方式更加SOA一些，不过JMX号称也要提供对非java客户端的支持，也就是跨语言了吧。。。

现在的JMX连接方式：
JMXServiceURL url = new JMXServiceURL("service:jmx:rmi:///jndi/rmi://localhost:9999/server");        JMXConnector jmxc = JMXConnectorFactory.connect(url, null);

看了下源码，貌似还是通过RMI来实现的，不知道它要怎么实现非java客户端支持。
从这里，我觉得JMX可以实现的，我们也都可以通过web Service实现，只是看在它有个“M”上，以后如果有什么系统管理，监控方面的，可以考虑使用它，也许开发，个人觉得还是使用web service好一些。

说到这里，感觉OSGI与JMX也好像，在看到JMX能够对MBean进行管理的时候，我就觉得跟OSGI很像，OSGI管理的是Bundle，找了找资源，原来早就有人考虑过了：
http://teamojiao.iteye.com/blog/438334

顺便，在查资料的时候，发现一个东西，
if your question means, how to manage an OSGi runtime with JMX, you should have a look at MAEXO (http://code.google.com/p/maexo/). With MAEXO bundles up and running you will transparently get MBeans for a fair amount of services of the OSGi runtime as well as MBeans for your own services and bundles. Just have a look at the screencast.

摘一些话：仅做参考

<网友回复>

一个大系统中，各内部模块系统之间的基于接口方式的互相调用和治理，使用ｊｍｘ是最佳方案．
带来的好处是
1.面向接口，远程调用对于开发人员是透明的，模块在调用ｊｍｘ接口时，与调用本地方法几乎相同．
2.可视化的治理界面，　通过　Jconsole等ｊｍｘ客户端，可以实时监控系统，并且可实时调用方法进行某些操作．

典型应用场景：　

某聊天系统，一台服务器作为 在线用户列表服务器 A1，　ｎ台服务器为用户提供聊天业务处理 N1 ,N2,N3...，
一台服务器作为后台治理系统A2．　

系统治理员现在进行下面这样一个操作，察看某用户是否在线，找到该用户，发现其在线，则将该用户加入黑名单，并踢下线．

对应的ｊｍｘ接口可以由以下几个：　

A1为A2提供查询在线用户ｊｍｘ接口，加入黑名单接口，kickout接口，
Ａ１为N1..等服务器提供以下接口：　注册业务服务器，添加在线用户．查找黑名单用户
N1...到N3为Ａ１提供kickout接口．

因此在上面的踢下线操作，则由用户在A2的ｗｅｂ界面发出，交由A1执行，A1记录黑名单之后，再找到用户所在业务服务器调用N1提供的接口让用户下线．

以上情形是在生产环境下的部署，而在开发工作，则可以将A1,A2,N...N3等功能合并在一个应用中调试．　由于使用的是ｊｍｘ接口，在本地调试合并之后，可以直接调用应用内部接口方法．

这样借助ｊｍｘ实现的应用模块的灵活组装与拆分，使得系统的可以根据负载需要，根据性能情况，灵活的拆分和整合部署分布式的应用．

替代方案，选择webservice,xmlrpc等，但是这些都需要手工编写或用工具生成大量的代码来辅助完成接口间的java对象序列化　。

经典ｊｍｘ案例：
１．Ｊｂｏｓｓ．使用ｊｍｘ治理内部的各个ｓｅｒｖｉｃｅ。
2．　基于ｊａｖａ的开源网管软件 Hyperic HQ ，通过ｊｍｘ与各被治理资源进行通讯和信息采集．

<网友回复>JMX是一个治理的框架。

当我们想使用JMX的时候，就要问，我们的系统当中有需要监控治理的资源或者对象吗？实事求是一点，我们不能为了想使用一个高端的技术，就歪曲系统的本来面目。

假如第一个问题是肯定的，接下来就是看这些资源是否有生命周期。

经典案例：jboss就是将所有可部署的组件作为资源来治理，这些组建都有其生命周期。这个理念甚至延伸到了其系统内部，将其内部的服务作为组件纳入到 JMX中来，成就了jboss基于jmx的微内核系统。



1. 异常处理机制的简单和应用。
   当Java程序违反了Java的语义规则时，Java虚拟机就会将发生的错误表示为一个异常。违反语义规则包括2种情况。一种是Java类库内置的语义。例如数组下标越界,会引发IndexOutOfBoundsException;访问null的对象时会引发NullPointerException。另一种情况就是Java允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用throw关键字引发异常。所有的异常都是java.lang.Thowable的子类。
2. Java的接口和C++的虚类的相同和不同处。

　　由于Java不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，该类要实现接口里面所有的方法和属性，接口里面的属性在默认状态下面都是public static,所有方法默认情况下是public.一个类可以实现多个接口。

1. 垃圾回收的优点和原理。并考虑2种回收机制。

　　Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。

4.线程同步的方法。

　　wait():使一个线程处于等待状态，并且释放所持有的对象的lock。

　　sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。

　　notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切地唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。

　　Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。

1. Error与Exception有什么区别？

　　Error表示系统级的错误和程序不必处理的异常，

　　Exception表示需要捕捉或者需要程序进行处理的异常。

1. 在java中一个类被声明为final类型，表示了什么意思？

　　表示该类不能被继承，是顶级类。

1. heap和stack有什么区别。

　　栈是一种线形集合，其添加和删除元素的操作应在同一段完成。栈按照后进先出的方式进行处理。堆是栈的一个组成元素。

1. 谈谈final, finally, finalize的区别。

　　final—修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载。 
　　finally—异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。 
　　finalize—方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。

1. Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)? 
   匿名的内部类是没有名字的内部类。不能extends(继承) 其它类，但一个内部类可以作为一个接口，由另一个内部类实现。
2. Static Nested Class 和 Inner Class的不同 
   Nested Class （一般是C++的说法），Inner Class (一般是JAVA的说法)。Java内部类与C++嵌套类最大的不同就在于是否有指向外部的引用上。 
    　　注： 静态内部类（Inner Class）意味着1创建一个static内部类的对象，不需要一个外部类对象，2不能从一个static内部类的一个对象访问一个外部类对象。

###  set集合从原理上如何保证不重复

1）在往set中添加元素时，如果指定元素不存在，则添加成功。也就是说，如果set中不存在(e==null ? e1==null : e.queals(e1))的元素e1,则e1能添加到set中。
2）具体来讲：当向HashSet中添加元素的时候，首先计算元素的hashcode值，然后用这个（元素的hashcode）%（HashMap集合的大小）+1计算出这个元素的存储位置，如果这个位置位空，就将元素添加进去；如果不为空，则用equals方法比较元素是否相等，相等就不添加，否则找一个空位添加。

###  HashMap和HashTable的主要区别是什么？两者底层实现的数据结构是什么？

HashMap和HashTable的区别：
二者都实现了Map 接口，是将惟一键映射到特定的值上；主要区别在于：
1)HashMap 没有排序，允许一个null 键和多个null 值,而Hashtable 不允许；
2)HashMap 把Hashtable 的contains 方法去掉了，改成containsvalue 和containsKey,因为contains 方法容易让人引起误解；
3)Hashtable 继承自Dictionary 类，HashMap 是Java1.2 引进的Map 接口的实现；
4)Hashtable 的方法是Synchronize 的，而HashMap 不是，在多个线程访问Hashtable 时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。Hashtable 和HashMap 采用的hash/rehash 算法大致一样，所以性能不会有很大的差异。

HashMap和HashTable的底层实现数据结构：
HashMap和Hashtable的底层实现都是数组+链表结构实现的

###  HashMap何时扩容，扩容的算法是什么？

HashMap何时扩容：
当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值---即当前数组的长度乘以加载因子的值的时候，就要自动扩容
扩容的算法是什么：
扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组

###  Java的虚拟机JVM的两个内存：栈内存和堆内存的区别是什么？

Java把内存划分成两种：一种是栈内存，一种是堆内存。两者的区别是：
1）栈内存：在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。 当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。
2）堆内存：堆内存用来存放由new创建的对象和数组。在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。

###  Java中对异常是如何进行分类的？

异常整体分类：
1）Java异常结构中定义有Throwable类。 Exception和Error为其子类。
2）其中Exception表示由于网络故障、文件损坏、设备错误、用户输入非法情况导致的异常
3）而Error标识Java运行时环境出现的错误，例如：JVM内存耗尽。



###  Java中的线程池共有几种？

Java四种线程池
第一种：newCachedThreadPool
创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。
第二种：newFixedThreadPool
创建一个指定工作线程数量的线程池
第三种：newScheduledThreadPool
创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。
第四种：newSingleThreadExecutor
创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。

###  volatile和synchronized区别

volatile和synchronized简介：
在Java中,为了保证多线程读写数据时保证数据的一致性,可以采用两种方式：
1）使用synchronized关键字
2）使用volatile关键字：用一句话概括volatile,它能够使变量在值发生改变时能尽快地让其他线程知道。
两者的区别：
1）volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住.
2）volatile仅能使用在变量级别,synchronized则可以使用在变量,方法.
3）volatile仅能实现变量的修改可见性,而synchronized则可以保证变量的修改可见性和原子性.
4）volatile不会造成线程的阻塞,而synchronized可能会造成线程的阻塞.

### Java的数据结构你用过哪些？Map与Set的本质区别是什么？

Java常见的数据结构有Collection和Map，其中Collection接口下包括List和Set接口，其下又有多个实现类如List下有ArrayList、LinkedList和Vector等实现类，Set下有HashSet、LinkedSet等实现类和SortedSet接口，HashSet下有LinkedHashSet子类，SortedSet接口下有TreeSet实现类。Map接口下有HashMap(有LinkedHashMap子类)、HashTable(有Properties子类)实现类和SortedMap接口(有TreeMap实现类)。 

我用过的数据结构主要有List、Set、Map、ArrayList、HashSet、HashMap、Properties等。 

Map与Set的本质区别我认为有：Set不能包含重复的元素，最多有一个空值，继承自Collection接口，底层是Map实现机制。Map不能包含重复的键，每个键最多对应一个映射的值，不能有空值键。两接口提供的方法不完全一样。 



### Http协议你了解吗？文件上传时，进度条的设计原理是什么？  
Http协议即超文本传输协议，属于应用层的面向对象的协议。它支持客户/服务器模式，简单快速、灵活、无连接和无状态。http请求由请求行、消息报头、请求正文组成，http响应由状态行、消息报头和响应正文组成。 

文件上传时进度条的设计原理：在java中主要用到I/O原理，已上传的数据值除以文件总大小的比值即实时进度的值。通过File类获取文件的总大小，在读取或写出文件时加一个进度计算的步骤，每读取或写出一次就计算进度值，更新进度条。


### Java中的Annotation的工作原理是什么？ 
Annotation提供一种机制，将程序的元素如:类，方法，属性，参数，本地变量，包和元数据联系起来。这样编译器可以将元数据存储在Class文件中。这样虚拟机和其它对象可以根据这些元数据来决定如何使用这些程序元素或改变它们的行为。







### JVM-如何判断对象存活与否

**JVM如何判断对象存活？**

1、**计数器**

2、**可达性分析**   （很多主流语言采用这种方法来判断对象是否存活）

计数器：每当有一个地方引用该对象时，计数器 +1；引用失效则 -1；

优点：实现简单，判定效率高。

缺点：难解决对象间的相互循环引用问题。

 

可达性分析：通过GC Roots的对象作作为起点，从这些起点向下去搜索，所走过的路径叫做引用链，当一个对象到GC Roots没有任何引用链连接时，则证明此对象不可达。

　　简单理解：1、对象A中引用了对象B，那么就称A到B可达。

　　　　　　　2、经历两次标记和筛选，第一次的标记和筛选并不能直接断定对象的死亡。等第二次确认没有可达的对象的时候才会真正确定。

　　可作为 `GC Root` 的对象有：
　　　　　　1.`Java`虚拟机栈（栈帧的本地变量表）中引用的对象
　　　　　　2.本地方法栈 中 `JNI`引用对象
　　　　　　3.方法区 中常量、类静态属性引用的对象

### CMS收集器和G1收集器的区别

**CMS收集器**：一款以获取最短回收停顿时间为目标的收集器，是基于“标记-清除”算法实现的，分为4个步骤：初始标记、并发标记、重新标记、并发清除。
**G1收集器**：面向服务端应用的垃圾收集器，过程：初始标记；并发标记；最终标记；筛选回收。

CMS特点：并发，低停顿

缺点：对CPU非常敏感，无法处理浮动垃圾，内存碎片过多时，会产生full gc（什么是浮动垃圾：并发清理阶段用户线程还在运行，这段时间就可能产生新的垃圾，新的垃圾在此次GC无法清除，只能等到下次清理）

G1特点：　是一款面向服务端应用的垃圾收集器，并行于并发，分代收集，空间整合，可预测的停顿（空间整合：由于G1使用了独立区域（Region）概念，G1从整体来看是基于“标记-整理”算法实现收集，从局部（两个Region）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片。

可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用这明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒）

缺点：暂时没在网上找到相关资料

### JVM的类加载机制是什么？有哪些实现方式？

类加载机制：
类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法去内，然后在堆区创建一个java.lang.Class对象，用来封装在方法区内的数据结构。类的加载最终是在堆区内的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。

类加载有三种方式：
1）命令行启动应用时候由JVM初始化加载
2）通过Class.forName（）方法动态加载
3）通过ClassLoader.loadClass（）方法动态加载

### JVM的常见垃圾回收算法？
1）标记-清楚算法：前后线标记处所有需要回收的对象，在标记完成后统一回收有被标记的对象。
2）复制算法：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当一块内存用完了，将其存在另外一块上面，然后再把已使用过的内存空间一次清理掉。
3）标记-整理算法：标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所一端移动，然后直接清理掉端边界以外的内存。
4）分代收集算法：一般是把Java堆分为新生代和老年代，根据各个年代的特点采用最适当的收集算法。新生代都发现有大批对象死去，选用复制算法。老年代中因为对象存活率高，必须使用“标记-清理”或“标记-整理”算法来进行回收。

### JVM调优的常见命令行工具有哪些？JVM常见的调优参数有哪些？
（1）JVM调优的常见命令工具包括：
1）jps命令用于查询正在运行的JVM进程，
2）jstat可以实时显示本地或远程JVM进程中类装载、内存、垃圾收集、JIT编译等数据
3）jinfo用于查询当前运行这的JVM属性和参数的值。
4）jmap用于显示当前Java堆和永久代的详细信息
5）jhat用于分析使用jmap生成的dump文件，是JDK自带的工具
6）jstack用于生成当前JVM的所有线程快照，线程快照是虚拟机每一条线程正在执行的方法,目的是定位线程出现长时间停顿的原因。

（2）JVM常见的调优参数包括：
-Xmx
指定java程序的最大堆内存, 使用java -Xmx5000M -version判断当前系统能分配的最大堆内存

-Xms
指定最小堆内存, 通常设置成跟最大堆内存一样，减少GC

-Xmn 
设置年轻代大小。整个堆大小=年轻代大小 + 年老代大小。所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。

-Xss
指定线程的最大栈空间, 此参数决定了java函数调用的深度, 值越大调用深度越深, 若值太小则容易出栈溢出错误(StackOverflowError)

-XX:PermSize
指定方法区(永久区)的初始值,默认是物理内存的1/64， 在Java8永久区移除, 代之的是元数据区， 由-XX:MetaspaceSize指定

-XX:MaxPermSize
指定方法区的最大值, 默认是物理内存的1/4， 在java8中由-XX:MaxMetaspaceSize指定元数据区的大小

-XX:NewRatio=n 
年老代与年轻代的比值，-XX:NewRatio=2, 表示年老代与年轻代的比值为2:1

-XX:SurvivorRatio=n
Eden区与Survivor区的大小比值，-XX:SurvivorRatio=8表示Eden区与Survivor区的大小比值是8:1:1，因为Survivor区有两个(from, to)

### ConcurrentHashMap加锁机制是什么，详细说一下？ 

HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。

### G1收集器简介？以及它的内存划分怎么样的？
（1）简介：
Garbage-First（G1，垃圾优先）收集器是服务类型的收集器，目标是多处理器机器、大内存机器。它高度符合垃圾收集暂停时间的目标，同时实现高吞吐量。Oracle JDK 7 update 4 以及更新发布版完全支持G1垃圾收集器

（2）G1的内存划分方式：
它是将堆内存被划分为多个大小相等的 heap 区,每个heap区都是逻辑上连续的一段内存(virtual memory). 其中一部分区域被当成老一代收集器相同的角色(eden, survivor, old), 但每个角色的区域个数都不是固定的。这在内存使用上提供了更多的灵活性

### 在重写equals方法时，需要遵循哪些约定，具体介绍一下？

重写equals方法时需要遵循通用约定：自反性、对称性、传递性、一致性.、非空性
1）自反性
对于任何非null的引用值x,x.equals(x)必须返回true。---这一点基本上不会有啥问题
2）对称性
对于任何非null的引用值x和y，当且仅当x.equals(y)为true时，y.equals(x)也为true。
3）传递性
对于任何非null的引用值x、y、z。如果x.equals(y)==true,y.equals(z)==true,那么x.equals(z)==true。
4） 一致性
对于任何非null的引用值x和y，只要equals的比较操作在对象所用的信息没有被修改，那么多次调用x.eqals(y)就会一致性地返回true,或者一致性的返回false。
5）非空性
所有比较的对象都不能为空。

### Synchronized优化后的锁机制简单介绍一下，包括自旋锁、偏向锁、轻量级锁、重量级锁？

自旋锁：
线程自旋说白了就是让cpu在做无用功，比如：可以执行几次for循环，可以执行几条空的汇编指令，目的是占着CPU不放，等待获取锁的机会。如果旋的时间过长会影响整体性能，时间过短又达不到延迟阻塞的目的。

偏向锁
偏向锁就是一旦线程第一次获得了监视对象，之后让监视对象“偏向”这个线程，之后的多次调用则可以避免CAS操作，说白了就是置个变量，如果发现为true则无需再走各种加锁/解锁流程。

轻量级锁：
轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁；

重量级锁
重量锁在JVM中又叫对象监视器（Monitor），它很像C中的Mutex，除了具备Mutex(0|1)互斥的功能，它还负责实现了Semaphore(信号量)的功能，也就是说它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait队列），前者负责做互斥，后一个用于做线程同步。

### 偏向锁、轻量级锁、重量级锁的对比：





## 参考

[Spring框架原理](http://www.cnblogs.com/grl214/p/6623330.html)

https://www.cnblogs.com/weiyi1314/p/7132314.html