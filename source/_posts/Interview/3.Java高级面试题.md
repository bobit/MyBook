---
title: Java高级面试题
toc: true
typora-copy-images-to: ../../gitbooks/static/images/
mathjax: true
abbrlink: fd0e5cbc
date: 2017-12-28 17:10:48
tags:
  - Interview
categories:
  - Interview
---





## HashMap 与 HashTable 区别



### HashMap理解

- HashMap 是一个散列桶（数组和链表），它存储的内容是键值对 key-value 映射
- HashMap 采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改
- HashMap 是非 synchronized，所以 HashMap 很快
- HashMap 可以接受 null 键和值，而 Hashtable 则不能（原因就是 equlas() 方法需要对象，因为 HashMap 是后出的 API 经过处理才可以）
- HashMap 是基于 hashing 的原理，使用 put(key, value) 存储对象到 HashMap 中，使用 get(key) 从 HashMap 中获取对象。当给 put() 方法传递键和值时，先对键调用 hashCode() 方法，计算并返回的 hashCode 是用于找到 Map 数组的 bucket 位置来储存 Node 对象。

### 应用场景

推荐的HashMap应用场景是单线程运行环境，并且不需要遍历操作的场景。这个推荐场景不是硬性条件。比如多线程操作HashMap，通过加锁或者加入同步控制依然能正常应用HashMap，只是需要加上同步操作的代价。

多线程的环境推荐ConcurrentHashMap ，我们知道 Hashtable 是 synchronized 的，但是 ConcurrentHashMap 同步性能更好，因为它仅仅根据同步级别对 map 的一部分进行上锁ConcurrentHashMap 当然可以代替 HashTable，但是 HashTable 提供更强的线程安全性。它们都可以用于多线程的环境，但是当 Hashtable 的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。由于 ConcurrentHashMap 引入了分割（segmentation），不论它变得多么大，仅仅需要锁定 Map 的某个部分，其它的线程不需要等到迭代完成才能访问 Map。简而言之，在迭代的过程中，ConcurrentHashMap 仅仅锁定 Map 的某个部分，而 Hashtable 则会锁定整个 Map。

### HashMap 与 HashTable 区别

- 继承和实现方式不同
HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。
Hashtable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。

- 默认容量不同
HashMap**默认的容量大小是16**；增加容量时，每次将容量变为“原始容量x2”。
Hashtable**默认的容量大小是11**；增加容量时，每次将容量变为“原始容量x2 + 1”。

- 线程安全性
HashTable 安全

- 效率不同
HashTable 要慢，因为加锁

- 对null值的处理不同
HashMap的key、value**都可以为null**。
Hashtable的key、value**都不可以为null**。

- 支持的遍历种类不同
HashMap**只支持Iterator(迭代器)遍历。**
而Hashtable**支持Iterator(迭代器)和Enumeration(枚举器)两种方式遍历。**

- 添加key-value时的hash值算法不同
HashMap添加元素时，是使用**自定义的哈希算法。**
Hashtable没有自定义哈希算法，而**直接采用的key的hashCode()。**

- 部分API不同
Hashtable**支持contains(Object value)方法，而且重写了toString()方法**；
而HashMap**不支持contains(Object value)方法，没有重写toString()方法。**

## spring

### 一、spring事务的传播机制（HibernateTransactionManager）**

   1.如果当前没有事务，就新建一个事务；如果已存在一个事务，就加入到这个事务中。

   2.支持当前事务，如果当前没有事务，以非事务方式执行。

   3.使用当前事务，如果当前没有事务，则抛出异常。

   4.新建事务，如果当前存在事务，则把当前事务挂起。

   5.以非事务方式执行，如果当前存在事务，则把当前事务挂起。

   6.以非事务方式执行，如果当前存在事务，则抛出异常。

   7.如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 1. 类似的操作。

### **二、spring事务隔离级别（Isolation Level)**

**ISOLATION_DEFAULT** 
这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.

另外四个与JDBC的隔离级别相对应；

**ISOLATION_READ_UNCOMMITTED** （未提交读）
这是事务最低的隔离级别，它充许别外一个事务可以看到这个事务未提交的数据。 
这种隔离级别会产生脏读，不可重复读和幻像读。

**ISOLATION_READ_COMMITTED** (提交读)
保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。 
这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。

**ISOLATION_REPEATABLE_READ** (可重复读)
这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。 
它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。

**ISOLATION_SERIALIZABLE** （序列化）
这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。 
除了防止脏读，不可重复读外，还避免了幻像读。

========================================================================================

脏读：指一个事务读取了一个未提交事务的数据

不可重复读：在一个事务内读取表中的某一行数据,多次读取结果不同.一个事务读取到了另一个事务提交后的数据.

虚读(幻读)：在一个事务内读取了别的事务插入的数据，导致前后读取不一致(insert)

========================================================================================

五个隔离级别：

脏不幻(金不换)

第一个是数据库默认

第二个会出现：脏读、不可重复读、幻读

第三个会出现：不可重复读、幻读

第四个会出现：幻读

第五个全部都不会出现

========================================================================================

MySQL

mysql默认的事务处理级别是 REPEATABLE-READ，也就是可重复读

Oracle

oracle数据库支持READ COMMITTED 和 SERIALIZABLE这两种事务隔离级别。

默认系统事务隔离级别是READ COMMITTED,也就是读已提交

## JMX

Java Management Extensions，Java管理扩展，初步看了些资料，以为是专门管理，监控jvm的一些信息的，特别是visual VM这个监控jvm的东西，还有一个添加JMX连接的时候（我自己想错了，那样的话应该叫jvm Management Extensions），其实他能使得基于java语言开发的程序能被管理，并且是可扩展的。

Jdk以前是通过JVMPI之类来监测Java程序运行中的jvm和系统的一系列情况，现在通过jmx就可以做到，这是通过java.lang.management 包来实现的，这个包是 JMX 在 JDK方面 的一个应用，并不是表示jmx就是一个监控jvm的东西。

我们可以用jmx来监控我们的系统，通过公布API的方式，但是，这里采用监控这个词，也是受了前面的例子的影响，实际上，个人觉得，就可以用jmx来开发我们的系统。

现在的jboss，hibernate，tomcat各种应用都号称实现了JMX规范，将可管理，可调用的MBean注册到MBeanServer中，通过一种类似“web服务”的方式公布出去，并且伴有一个名字，可以通过该名字找到该MBean。并且，这里的MBean是可以被管理的，说到这里又想到了OSGI。

## JMX与Web Service

个人认为，我们实现JMX规范，将东西发布出去，和通过web Service的方式是很类似的，也是可以远程调用的，只是相对的web Service的方式更加SOA一些，不过JMX号称也要提供对非java客户端的支持，也就是跨语言了吧。。。

现在的JMX连接方式：
JMXServiceURL url = new JMXServiceURL("service:jmx:rmi:///jndi/rmi://localhost:9999/server");        JMXConnector jmxc = JMXConnectorFactory.connect(url, null);

看了下源码，貌似还是通过RMI来实现的，不知道它要怎么实现非java客户端支持。
从这里，我觉得JMX可以实现的，我们也都可以通过web Service实现，只是看在它有个“M”上，以后如果有什么系统管理，监控方面的，可以考虑使用它，也许开发，个人觉得还是使用web service好一些。

说到这里，感觉OSGI与JMX也好像，在看到JMX能够对MBean进行管理的时候，我就觉得跟OSGI很像，OSGI管理的是Bundle，找了找资源，原来早就有人考虑过了：
http://teamojiao.iteye.com/blog/438334

顺便，在查资料的时候，发现一个东西，
if your question means, how to manage an OSGi runtime with JMX, you should have a look at MAEXO (http://code.google.com/p/maexo/). With MAEXO bundles up and running you will transparently get MBeans for a fair amount of services of the OSGi runtime as well as MBeans for your own services and bundles. Just have a look at the screencast.

摘一些话：仅做参考

<网友回复>

一个大系统中，各内部模块系统之间的基于接口方式的互相调用和治理，使用ｊｍｘ是最佳方案．
带来的好处是
1.面向接口，远程调用对于开发人员是透明的，模块在调用ｊｍｘ接口时，与调用本地方法几乎相同．
2.可视化的治理界面，　通过　Jconsole等ｊｍｘ客户端，可以实时监控系统，并且可实时调用方法进行某些操作．

典型应用场景：　

某聊天系统，一台服务器作为 在线用户列表服务器 A1，　ｎ台服务器为用户提供聊天业务处理 N1 ,N2,N3...，
一台服务器作为后台治理系统A2．　

系统治理员现在进行下面这样一个操作，察看某用户是否在线，找到该用户，发现其在线，则将该用户加入黑名单，并踢下线．

对应的ｊｍｘ接口可以由以下几个：　

A1为A2提供查询在线用户ｊｍｘ接口，加入黑名单接口，kickout接口，
Ａ１为N1..等服务器提供以下接口：　注册业务服务器，添加在线用户．查找黑名单用户
N1...到N3为Ａ１提供kickout接口．

因此在上面的踢下线操作，则由用户在A2的ｗｅｂ界面发出，交由A1执行，A1记录黑名单之后，再找到用户所在业务服务器调用N1提供的接口让用户下线．

以上情形是在生产环境下的部署，而在开发工作，则可以将A1,A2,N...N3等功能合并在一个应用中调试．　由于使用的是ｊｍｘ接口，在本地调试合并之后，可以直接调用应用内部接口方法．

这样借助ｊｍｘ实现的应用模块的灵活组装与拆分，使得系统的可以根据负载需要，根据性能情况，灵活的拆分和整合部署分布式的应用．

替代方案，选择webservice,xmlrpc等，但是这些都需要手工编写或用工具生成大量的代码来辅助完成接口间的java对象序列化　。

经典ｊｍｘ案例：
１．Ｊｂｏｓｓ．使用ｊｍｘ治理内部的各个ｓｅｒｖｉｃｅ。
2．　基于ｊａｖａ的开源网管软件 Hyperic HQ ，通过ｊｍｘ与各被治理资源进行通讯和信息采集．

<网友回复>JMX是一个治理的框架。

当我们想使用JMX的时候，就要问，我们的系统当中有需要监控治理的资源或者对象吗？实事求是一点，我们不能为了想使用一个高端的技术，就歪曲系统的本来面目。

假如第一个问题是肯定的，接下来就是看这些资源是否有生命周期。

经典案例：jboss就是将所有可部署的组件作为资源来治理，这些组建都有其生命周期。这个理念甚至延伸到了其系统内部，将其内部的服务作为组件纳入到 JMX中来，成就了jboss基于jmx的微内核系统。



1. 异常处理机制的简单和应用。
   当Java程序违反了Java的语义规则时，Java虚拟机就会将发生的错误表示为一个异常。违反语义规则包括2种情况。一种是Java类库内置的语义。例如数组下标越界,会引发IndexOutOfBoundsException;访问null的对象时会引发NullPointerException。另一种情况就是Java允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用throw关键字引发异常。所有的异常都是java.lang.Thowable的子类。
2. Java的接口和C++的虚类的相同和不同处。

　　由于Java不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，该类要实现接口里面所有的方法和属性，接口里面的属性在默认状态下面都是public static,所有方法默认情况下是public.一个类可以实现多个接口。

1. 垃圾回收的优点和原理。并考虑2种回收机制。

　　Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。

4.线程同步的方法。

　　wait():使一个线程处于等待状态，并且释放所持有的对象的lock。

　　sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。

　　notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切地唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。

　　Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。

1. Error与Exception有什么区别？

　　Error表示系统级的错误和程序不必处理的异常，

　　Exception表示需要捕捉或者需要程序进行处理的异常。

1. 在java中一个类被声明为final类型，表示了什么意思？

　　表示该类不能被继承，是顶级类。

1. heap和stack有什么区别。

　　栈是一种线形集合，其添加和删除元素的操作应在同一段完成。栈按照后进先出的方式进行处理。堆是栈的一个组成元素。

1. 谈谈final, finally, finalize的区别。

　　final—修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载。 
　　finally—异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。 
　　finalize—方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。

1. Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)? 
   匿名的内部类是没有名字的内部类。不能extends(继承) 其它类，但一个内部类可以作为一个接口，由另一个内部类实现。
2. Static Nested Class 和 Inner Class的不同 
   　　Nested Class （一般是C++的说法），Inner Class (一般是JAVA的说法)。Java内部类与C++嵌套类最大的不同就在于是否有指向外部的引用上。 
      　　注： 静态内部类（Inner Class）意味着1创建一个static内部类的对象，不需要一个外部类对象，2不能从一个static内部类的一个对象访问一个外部类对象。



## 参考

[Spring框架原理](http://www.cnblogs.com/grl214/p/6623330.html)