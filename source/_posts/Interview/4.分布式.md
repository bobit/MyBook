---
title: 分布式相关
toc: true
typora-copy-images-to: ../../gitbooks/static/images/
mathjax: true
abbrlink: 9a84f5c8
date: 2017-12-28 17:17:35
tags:
  - Interview
categories:
  - Interview
---

### 分布式

### 分布式架构的定义

服务组件是分布在网络计算机上  
组件之间通过消息传递   

分布式(distributed), 是当业务量、数据量增加时，可以通过任意增加减少服务器数量来解决问题。
集群时代
至少部署两台Redis服务器构成一个小的集群，主要有2个目的：
高可用性：在主机挂掉后，自动故障转移，使前端服务对用户无影响。
读写分离：将主机读压力分流到从机上。
可在客户端组件上实现负载均衡，根据不同服务器的运行情况，分担不同比例的读请求压力。
逻辑图：

### 分布式集群时代

当缓存数据量不断增加时，单机内存不够使用，需要把数据切分不同部分，分布到多台服务器上。
可在客户端对数据进行分片，数据分片算法详见C#一致性Hash详解、C#之虚拟桶分片。
逻辑图：
这里写图片描述
大规模分布式集群时代
当数据量持续增加时，应用可根据不同场景下的业务申请对应的分布式集群。 这块最关键的是缓存治理这块，其中最重要的部分是加入了代理服务。 应用通过代理访问真实的Redis服务器进行读写，这样做的好处是：
避免越来越多的客户端直接访问Redis服务器难以管理，而造成风险。
在代理这一层可以做对应的安全措施，比如限流、授权、分片。
避免客户端越来越多的逻辑代码，不但臃肿升级还比较麻烦。
代理这层无状态的，可任意扩展节点，对于客户端来说，访问代理跟访问单机Redis一样。
目前楼主公司使用的是客户端组件和代理两种方案并存，因为通过代理会影响一定的性能。 代理这块对应的方案实现有Twitter的Twemproxy和豌豆荚的codis。
逻辑图：

### 高并发处理

高并发处理  a) 了解一点高并发性问题，比如一W人抢一张票时，如何保证票在没买走的情况下所有人都能看见这张票，显然是不能用同步机制，因为synchronize是锁同步一次只能一个人进行。这时候可以用到锁机制，采用乐观锁可以解决这个问题。乐观锁的简单意思是在不锁定表的情况下，利用业务的控制来解决并发问题，这样即保证数据的可读性，又保证保存数据的排他性，保证性能的同时解决了并发带来的脏读数据问题。 

### SSM优缺点、使用场景

1. Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。
2. Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。
3. Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。
4. 总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。

### 高可用

高可用（High Availability），是当一台服务器停止服务后，对于业务及用户毫无影响。 停止服务的原因可能由于网卡、路由器、机房、CPU负载过高、内存溢出、自然灾害等不可预期的原因导致，在很多时候也称单点问题。
（1）解决单点问题主要有2种方式：
主备方式
这种通常是一台主机、一台或多台备机，在正常情况下主机对外提供服务，并把数据同步到备机，当主机宕机后，备机立刻开始服务。
Redis HA中使用比较多的是keepalived，它使主机备机对外提供同一个虚拟IP，客户端通过虚拟IP进行数据操作，正常期间主机一直对外提供服务，宕机后VIP自动漂移到备机上。
优点是对客户端毫无影响，仍然通过VIP操作。
缺点也很明显，在绝大多数时间内备机是一直没使用，被浪费着的。
主从方式
这种采取一主多从的办法，主从之间进行数据同步。 当Master宕机后，通过选举算法(Paxos、Raft)从slave中选举出新Master继续对外提供服务，主机恢复后以slave的身份重新加入。
主从另一个目的是进行读写分离，这是当单机读写压力过高的一种通用型解决方案。 其主机的角色只提供写操作或少量的读，把多余读请求通过负载均衡算法分流到单个或多个slave服务器上。
缺点是主机宕机后，Slave虽然被选举成新Master了，但对外提供的IP服务地址却发生变化了，意味着会影响到客户端。 解决这种情况需要一些额外的工作，在当主机地址发生变化后及时通知到客户端，客户端收到新地址后，使用新地址继续发送新请求。
（2）数据同步
无论是主备还是主从都牵扯到数据同步的问题，这也分2种情况：
同步方式：当主机收到客户端写操作后，以同步方式把数据同步到从机上，当从机也成功写入后，主机才返回给客户端成功，也称数据强一致性。 很显然这种方式性能会降低不少，当从机很多时，可以不用每台都同步，主机同步某一台从机后，从机再把数据分发同步到其他从机上，这样提高主机性能分担同步压力。 在redis中是支持这杨配置的，一台master，一台slave，同时这台salve又作为其他slave的master。
异步方式：主机接收到写操作后，直接返回成功，然后在后台用异步方式把数据同步到从机上。 这种同步性能比较好，但无法保证数据的完整性，比如在异步同步过程中主机突然宕机了，也称这种方式为数据弱一致性。
Redis主从同步采用的是异步方式，因此会有少量丢数据的危险。还有种弱一致性的特例叫最终一致性，这块详细内容可参见CAP原理及一致性模型。
（3）方案选择
keepalived方案配置简单、人力成本小，在数据量少、压力小的情况下推荐使用。 如果数据量比较大，不希望过多浪费机器，还希望在宕机后，做一些自定义的措施，比如报警、记日志、数据迁移等操作，推荐使用主从方式，因为和主从搭配的一般还有个管理监控中心。
宕机通知这块，可以集成到客户端组件上，也可单独抽离出来。 Redis官方Sentinel支持故障自动转移、通知等，详情见低成本高可用方案设计(四)。
逻辑图：

### session共享

使用redis存储session信息，主从复制慢可以在代码中手动写入

### 分布式事务 

​	两阶段提交协议
​	使用消息中间件

3.负载均衡

4.分布式锁

一致性hash算法
用处：分布式缓存

算法描述：

```
先构造一个长度为232的整数环（这个环被称为一致性Hash环），根据节点名称的Hash值（其分布为[0, 232-1]）将服务器节点放置在这个Hash环上，然后根据数据的Key值计算得到其Hash值（其分布也为[0, 232-1]），接着在Hash环上顺时针查找距离这个Key值的Hash值最近的服务器节点，完成Key到服务器的映射查找。
```

避免hash倾斜性方法:引入虚拟节点

```
将一个物理节点拆分为多个虚拟节点，并且同一个物理节点的虚拟节点尽量均匀分布在Hash环上
```

### 消息队列的应用场景

```
1.异步处理（如发送短信）
2.应用解偶
3.流量销峰（秒杀活动限流）
4.日志处理
5.消息通讯（点对点通信或聊天室）
```

### 高并发下的性能优化

```
1.调整项目结构，增加服务器资源，集群或分布式，负载均衡
2.数据库优化
3.代码优化（使用多线程+算法优化）
4.合理使用缓存
5.html静态化，图片存于服务器
```

### 接口如何处理重复请求

```
主要是利用唯一Token值与提交参数相匹配验证。
看到一篇不错的文章，转载不了就复制下来了，没事可以看看。
```

现在很多高谈阔论，高并发，大流量，分布式，SOA，名词一大堆往往抓不住要点，对于熟悉的人来说，言之无味，而对不熟悉的人来说，更类似大师讲法，除了增加神秘感外，让人越发无从了解。

### 解决方案

没有统一的解决方案，所以任何系统都要结合业务自身特点，与软件，硬件平衡一起考虑完整的解决方案。

对于一个电商平台，可以大致描述一下其基础架构， 
1.一个接入的web集群，用来接入链接 
2.一个状态保存系统 
3.拆分成多个相对独立的应用系统，每个系统都无状态，可横向扩展。 
4.根据应用和数据规模，将数据拆分成多个相对对立的存储系统 
可以是类似：用户系统，订单系统，支付系统这样按功能拆分， 
也可以再拆分成：用户1系统，用户2系统…这些系统功能完全一致，只是保存了不同用户群的数据

其中每个存储系统自己负责容错，不同存储系统通过应用系统通过内部消息来衔接，总是假定其他系统可能故障，也就必须考虑恢复或冲正。

这一切，尤其是3和4显然更多依赖于业务的分析与设计，那么从技术角度，最终的系统就是一个完全分布式的系统，可以支持几乎无限的扩展。而某些技术，热门中间件，框架，其实仅仅是一个技术手段，并没有想象的那么重要。





