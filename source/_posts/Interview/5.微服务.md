---
title: 面试题-微服务相关
toc: true
typora-copy-images-to: ../../gitbooks/static/images/
mathjax: true
abbrlink: a5e59955
tags:
  - Interview
categories:
  - Interview
date: 2017-12-28 17:11:22
---



## Spring

### Spring整合ORM框架时，事务管理用哪个类？是Spring控制事务的提交还是ORM框架控制？同一事务中执行两个更新操作，它的工作原理是怎样的？ 

Spring整合ORM框架时事务管理用的是相应ORM框架的事务管理器类如Hibernate对应于HibernateTransactionManager，JPA对应于JpaTransactionManager等。整合过后可配置由Spring控制事务的提交。事务提交前执行两个更新操作(不清楚其工作原理)。

### Spring事务的传播机制

一、spring事务的传播机制（HibernateTransactionManager）**

   1.如果当前没有事务，就新建一个事务；如果已存在一个事务，就加入到这个事务中。

   2.支持当前事务，如果当前没有事务，以非事务方式执行。

   3.使用当前事务，如果当前没有事务，则抛出异常。

   4.新建事务，如果当前存在事务，则把当前事务挂起。

   5.以非事务方式执行，如果当前存在事务，则把当前事务挂起。

   6.以非事务方式执行，如果当前存在事务，则抛出异常。

   7.如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 1. 类似的操作。

**二、spring事务隔离级别（Isolation Level)**

**ISOLATION_DEFAULT** 
这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.

另外四个与JDBC的隔离级别相对应；

**ISOLATION_READ_UNCOMMITTED** （未提交读）
这是事务最低的隔离级别，它充许别外一个事务可以看到这个事务未提交的数据。 
这种隔离级别会产生脏读，不可重复读和幻像读。

**ISOLATION_READ_COMMITTED** (提交读)
保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。 
这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。

**ISOLATION_REPEATABLE_READ** (可重复读)
这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。 
它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。

**ISOLATION_SERIALIZABLE** （序列化）
这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。 
除了防止脏读，不可重复读外，还避免了幻像读。

========================================================================================

脏读：指一个事务读取了一个未提交事务的数据

不可重复读：在一个事务内读取表中的某一行数据,多次读取结果不同.一个事务读取到了另一个事务提交后的数据.

虚读(幻读)：在一个事务内读取了别的事务插入的数据，导致前后读取不一致(insert)

========================================================================================

五个隔离级别：

脏不幻(金不换)

第一个是数据库默认

第二个会出现：脏读、不可重复读、幻读

第三个会出现：不可重复读、幻读

第四个会出现：幻读

第五个全部都不会出现

========================================================================================

MySQL

mysql默认的事务处理级别是 REPEATABLE-READ，也就是可重复读

Oracle

oracle数据库支持READ COMMITTED 和 SERIALIZABLE这两种事务隔离级别。

默认系统事务隔离级别是READ COMMITTED,也就是读已提交

### Spring的特性

1.方便解耦，简化开发
通过Spring提供的IoC容器，我们可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。
2.AOP编程的支持
通过Spring提供的AOP功能，方便进行面向切面的编程。
3.声明事物的支持
在Spring中，我们可以从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。
4.方便程序的测试
可以用非容器依赖的编程方式进行几乎所有的测试工作。例如：Spring对Junit4支持，可以通过注解方便的测试Spring程序。 
5.方便集成各种优秀框架
Spring不排斥各种优秀的开源框架，相反，Spring可以降低各种框架的使用难度，Spring提供了对各种优秀框架（如Struts,Hibernate、Hessian、Quartz）等的直接支持。
6.降低Java EE API的使用难度
Spring对很多难用的Java EE API（如JDBC，JavaMail，远程调用等）提供了一个薄薄的封装层，通过Spring的简易封装，这些Java EE API的使用难度大为降低。

### spring 核心

#### aop

b) AOP：面向切面编程，主要是管理系统层的业务，比如日志，权限，事物等。AOP是将封装好的对象剖开，找出其中对多个对象产生影响的公共行为，并将其封装为一个可重用的模块，这个模块被命名为切面（aspect），切面将那些与业务逻辑无关，却被业务模块共同调用的逻辑提取并封装起来，减少了系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。

#### ioc

a) IOC：IOC控制反转主要强调的是程序之间的关系是由容器控制的，容器控制对象，控制了对外部资源的获取。而反转即为，在传统的编程中都是由我们创建对象获取依赖对象，而在IOC中是容器帮我们创建对象并注入依赖对象，正是容器帮我们查找和注入对象，对象是被获取，所以叫反转。

#### 使用Spring有什么好处

◆Spring能有效地组织你的中间层对象,无论你是否选择使用了EJB。如果你仅仅使用了Struts或其他的包含了J2EE特有APIs的framework，你会发现Spring关注了遗留下的问题，。
◆Spring能消除在许多工程上对Singleton的过多使用。根据我的经验，这是一个主要的问题，它减少了系统的可测试性和面向对象特性。
◆Spring能消除使用各种各样格式的属性定制文件的需要,在整个应用和工程中，可通过一种 一致的方法来进行配置。曾经感到迷惑，一个特定类要查找迷幻般的属性关键字或系统属性,为此不得不读Javadoc乃至源编码吗？有了Spring，你可 很简单地看到类的JavaBean属性。倒置控制的使用(在下面讨论)帮助完成这种简化。
◆Spring能通过接口而不是类促进好的编程习惯，减少编程代价到几乎为零。
◆Spring被设计为让使用它创建的应用尽可能少的依赖于他的APIs。在Spring应用中的大多数业务对象没有依赖于Spring。
◆使用Spring构建的应用程序易于单元测试。
◆Spring能使EJB的使用成为一个实现选择,而不是应用架构的必然选择。你能选择用POJOs或local EJBs来实现业务接口，却不会影响调用代码。
◆Spring帮助你解决许多问题而无需使用EJB。Spring能提供一种EJB的替换物，它们适于许多web应用。例如,Spring能使用AOP提供声明性事务而不通过使用EJB容器，如果你仅仅需要与单个的数据库打交道，甚至不需要JTA实现。
■Spring为数据存取提供了一致的框架,不论是使用JDBC或O/R mapping产品（如Hibernate）。
Spring确实使你能通过最简单可行的解决办法解决你的问题。这些特性是有很大价值的。
总结起来，Spring有如下优点：
◆低侵入式设计，代码污染极低
◆ 独立于各种应用服务器，可以真正实现Write Once,Run Anywhere的承诺
◆Spring的DI机制降低了业务对象替换的复杂性
◆Spring并不完全依赖于Spring，开发者可自由选用Spring框架的部分或全部

#### 事物的理解

a) 事物具有原子性，一致性，持久性，隔离性
b) 原子性：是指在一个事物中，要么全部执行成功，要么全部失败回滚。
c) 一致性：事物执行之前和执行之后都处于一致性状态
d) 持久性：事物多数据的操作是永久性
e) 隔离性：当一个事物正在对数据进行操作时，另一个事物不可以对数据进行操作，也就是多个并发事物之间相互隔离。

### springmvc

#### Spring MVC Framework有这样一些特点

1。它是基于组件技术的.全部的应用对象,无论控制器和视图,还是业务对象之类的都是java组件.并且和Spring提供的其他基础结构紧密集成.
2。不依赖于Servlet API(目标虽是如此,但是在实现的时候确实是依赖于Servlet的)
3。可以任意使用各种视图技术,而不仅仅局限于JSP
4。支持各种请求资源的映射策略
5。它应是易于扩展的

#### springMVC的执行流程

springMVC是由dispatchservlet为核心的分层控制框架。首先客户端发出一个请求，web服务器解析请求url并去匹配dispatchservlet的映射url，如果匹配上就将这个请求放入到dispatchservlet，dispatchservlet根据mapping映射配置去寻找相对应的handel，然后把处理权交给找到的handel，handel封装了处理业务逻辑的代码，当handel处理完后会返回一个逻辑视图modelandview给dispatchservlet，此时的modelandview是一个逻辑视图不是一个正式视图，所以dispatchservlet会通过viewresource视图资源去解析modelandview，然后将解析后的参数放到view中返回到客户端并展现。



#### 如果你也用过struts2.简单介绍下springMVC和struts2的区别有哪些

1. springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。
2. springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。
3. Struts采用值栈存储请求和响应的数据，通过OGNL存取数据， springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。

### struts

### 说说Struts2的工作原理？ 

客户发起相应请求-》请求被提交到一系列有序的Filter中如ActionContextCleanUp和FilterDispatcher等-》ActionProxy代理类通过配置文件如struts.xml找到需要调用的Action类-》ActionProxy创建一个ActionInvocation的实例，同时ActionInvocation通过代理模式调用Action。但在调用之前ActionInvocation会根据配置加载Action相关的所有Interceptor-》ActionInvocation初始化时，根据配置，加载Action相关的所有Interceptor-》通过ActionInvocation.invoke方法调用Action实现时，执行Interceptor-》一旦Action执行完毕，ActionInvocation负责根据struts.xml中的配置找到对应的返回结果。如上文中将结构返回“add.jsp”，若是返回另外一个action，那么该流程又得走一遍。

#### Struts1与Struts2的区别  

简单来说二者的区别是：一个是Stuts1 ，一个是Stuts2，这是最大的区别，技术方面，Stuts1有个核心控制器，但是只提供了一个接口，也就是execute，还要配置actionform之类的，很麻烦，所以依赖性比较强；而Stuts2是针对拦截器开发的，也就是所谓的AOP思想，可以配置多个action，用起来比较方便，但是因为请求之前的拦截器有一些注入的操作，速度相对Stuts1来说慢一点。

#### Struts1的一些缺点

Struts2既然是从Struts1发展而来，但实际上Struts2与Struts1在框架的设计思想上面还是有很大的区别，Struts2是以WebWork的设计思想为核心，为什么Struts2不沿用Struts1的设计思想，毕竟Struts1在目前的企业应用中还是有非常大的市场在的，那么，来看下Struts1的一些缺点吧：
​        1）支持的表现层技术单一
​        2）与Servlet API严重耦合，这点可以从Action的Execute的方法声明里面就可以看的出来
​        3）代码依赖Struts1 API，有侵入性，这点可以从写Action类和FormBean的时候看的出来，Action必须实现Struts的Action类
​        而Struts2之所以以WebWork的设计思想为其核心，一点就是最近WebWork的上升势头，再就是WebWork没有Struts1上面的那些缺点，更符合MVC的设计思想，也更利于代码的复用。
​        基于以上介绍可以看的出，Struts2体系结构与Struts1的体系结构有很大的差别，Struts1是使用ActionServlet做为其中心处理器，Struts2则使用一个拦截器（FilterDispatcher）做为其中心处理器，这样做的一个好处就是将Action类和Servlet API进行了分离。
​		

#### Struts2工作流程

a) 客户端发出一个请求到servlet容器
b) 请求经过一些列过滤被filterdispatcher调用，filterdispatch通过actionMapper去找相对应的action。
c) Actionmapper找到对应的action返回给filterdispatch，dispatch把处理权交给actionproxy
d) Actionproxy通过配置文件找到对应的action类
e) Actionproxy创建一个actionIinvocation的实例处理业务逻辑
f) 一旦action处理完毕，actioninvocation负责根据stuts.xml的配置找到对应的返回结果。返回结果通常是jsp页面。

## SpringBoot

#### Spring Boot、Spring MVC 和 Spring 有什么区别

SpringFrame
SpringFramework 最重要的特征是依赖注入。所有 SpringModules 不是依赖注入就是 IOC 控制反转。
当我们恰当的使用 DI 或者是 IOC 的时候，我们可以开发松耦合应用。松耦合应用的单元测试可以很容易的进行。
SpringMVC
Spring MVC 提供了一种分离式的方法来开发 Web 应用。通过运用像 DispatcherServelet，MoudlAndView 和 ViewResolver 等一些简单的概念，开发 Web 应用将会变的非常简单。
SpringBoot
Spring 和 SpringMVC 的问题在于需要配置大量的参数。

## SpringCloud

### spring aop的应用场景：

AOP用来封装横切关注点，具体可以在下面的场景中使用
Authentication 权限
Caching 缓存
Context passing 内容传递
Error handling 错误处理
Lazy loading 懒加载
Debugging 调试
logging, tracing, profiling and monitoring 记录跟踪 优化 校准
Performance optimization 性能优化
Persistence 持久化
Resource pooling 资源池
Synchronization 同步
Transactions 事务

### 什么是springboot

Spring Boot提供了一种新的编程范式，用来简化spring应用的初始搭建以及开发过程，让我们可以更加敏捷地开发Spring应用程序，专注于应用程序的功能，不用在Spring的配置上多花功 夫，甚至完全不用配置。实际上，Spring Boot的一项重要工作就是让Spring配置不再成为你成功路上的绊脚石。

简而言之，从本质上来说，springboot是一个专注于框架的框架。Spring Boot就是对各种框架的整合，让他们集成在一起更加简单，简化了我们在集成过程中的模板化配置，它做了那些没有它你自己也会去做的Spring Bean配置。你不用再写这些样板配置了，可以专注于应用程序的逻辑，这些才是应用程序独一无二的东西。

**可以做什么**

- 自动配置(自动配置 spring)

以往，在任何的spring项目中，你都会找到Java配置或一大堆的XML配置文件，它们为应用程序开启了特定的特性和功能。看以下几个例子: 

1. web.xml
2. jdbcTemplate
3. 事务管理
   在以上三个例子中，很多配置都是复杂并且模板化，这提高了我们开发的成本。而在springboot中这些都自动为我们做好了，让开发人员更加专注于业务需求的开发。

- 起步依赖(简化maven配置)
  举个例子，假设你正在用Spring MVC构造一个REST API，并将JSON（JavaScript Object Notation）作为资源表述。此外，你还想运用遵循JSR-303规范的声明式校验，并使用嵌入式的Tomcat服务器来提供服务。要实现以上目标，你在Maven或Gradle里至少需要以下8个依赖：

```
org.springframework:spring-core 
org.springframework:spring-web 
org.springframework:spring-webmvc 
com.fasterxml.jackson.core:jackson-databind 
org.hibernate:hibernate-validator
org.apache.tomcat.embed:tomcat-embed-core org.apache.tomcat.embed:tomcat-embed-el 
org.apache.tomcat.embed:tomcat-embed-logging-juli
```

不过，如果打算利用Spring Boot的起步依赖，你只需添加Spring Boot的Web起步依赖（org.springframework.boot:spring-boot-starter-web），仅此一个。它会根据依赖传递把其他所需依赖引入项目里，也减少依赖数量，你都不用考虑它们。
比起减少依赖数量，起步依赖还引入了一些微妙的变化。向项目中添加了Web起步依赖，实际上指定了应用程序所需的一类功能(条件注入:发现有相应包就自动配置相应功能, @ConditionalOn*)。因为应用是个Web应用程序，所以加入了Web起步依赖。与之类似，如果应用程序要用到JPA持久化，那么就可以加入jpa起步依赖。如果需要安全功能，那就加入security起步依赖。 
简而言之，你不再需要考虑支持某种功能要用什么库了，引入相关起步依赖就行。此外，Spring Boot的起步依赖还把你从“需要这些库的哪些版本”这个问题里解放了出来。起步依赖引入的库的版本都是经过测试的，因此你可以完全放心，它们之间不会出现不兼容的情况。

- Actuator

> Actuator则要提供在运行时检视应用程序内部情况的能力。安装了Actuator就能窥探应用程序的内部情况了，包括如下细节：

1. Spring应用程序上下文里配置的Bean
2. Spring Boot的自动配置做的决策
3. 应用程序取到的环境变量、系统属性、配置属性和命令行参数
4. 应用程序里线程的当前状态
5. 应用程序最近处理过的HTTP请求的追踪情况
6. 各种和内存用量、垃圾回收、Web请求以及数据源用量相关的指标

> Actuator通过Web端点和shell界面向外界提供信息。如果要借助shell界面，你可以打开SSH（Secure Shell），登入运行中的应用程序，发送指令查看它的情况。

- 内嵌容器

> 可以通过配置插件，为springboot提供不同类型的容器。只需要通过java –jar 的方式即可启动应用程序。
> 嵌入的tomcat无需部署war文件

- YML配置文件
  可以使用特定的方式来进行配置（Properties文件方式或Yaml文件方式）

### springboot常用的starter有哪些

spring-boot-starter-web嵌入tomcat和webkaifa需要servlet与jsp支持

spring-boot-starter-data-jpa数据库支持

spring-boot-starter-data-redis数据库支持

spring-boot-starter-data-solr solr支持

mybatis-spring-boot-starter第三方的mybatis集成starter



### springboot自动配置的原理

在spring程序main方法中添加@SpringBootApplication或者@EnableAutoConfiguration,会自动去maven中读取每个starter中的spring.factories文件，该文件配置了所有需要被创建spring容器中的bean

### springboot读取配置文件的方式

springboot默认读取配置文件为application.properties或者application.yml

springboot集成mybatis的过程
添加mybatis的starter maven依赖mybatis-spring-boot-starter
在mybatis的接口中添加@Mapper注解
在application.yml配置数据源信息

### springboot如何添加【修改代码】自动重启功能

添加开发者工具·spring-boot-devtools



### 什么是微服务

以前的模式是所有的代码在同一个工程中 部署在同一个服务器中 同一个项目的不同模块不同功能互相抢占资源

微服务将工程根据不同的业务规则拆分成微服务，微服务部署在不同的机器上， 服务之间进行相互调用。java微服务的框架有dubbo（只能用来做微服务），springCloud（提供了服务的发现，断路器等）。

### springcloud如何实现服务的注册和发现

服务在发布时，指定对应的服务名（服务名包括了IP地址和端口），将服务注册到注册中心（eureka或者zookeeper），这一过程时springcloud自动实现  只需要在main方法添加@EnableDisscoveryClient 同一个服务修改端口就可以启动多个实例。

调用方法：传递服务名称通过注册中心获取所有的可用实例，通过负载均衡策略调用（ribbon和feign）对应的服务

### Ribbon和Feign的区别

Ribbon和Feign都是用于调用其他服务，不过方式不同。

1. 启动类使用的注解不同，Ribbon使用的时@RibbonClient，Feign用的时@EnableFeignClients
2. 服务的指定位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口使用@FeignClient声明。
3. 调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。Feign则是在Ribbon的基础进行了一次改进，采用接口的方式，将需要调用的其他服务的方法定义成抽象方法即可。不需要自己构建http请求。不过要注意的是抽象方法的注解、方法签名要和提供服务的方法完全一致。

### SpringCloud断路器的作用

当一个服务调用另一个服务由于网络原因或者自身原因出现问题时 ，调用者就会等待被调者的响应，当更多的服务请求到这些资源时，导致更多的请求等待，这样就会发生连锁效应，断路器就是解决这一问题的。
断路器有以下状态：
完全打开
一定时间内，达到一定的次数无法调用，并且多次检测没有恢复的迹象，断路器完全打开，那么下次的请求不会请求到该服务。
半开
短时间内有回复迹象，断路器会将部分请求发送给服务，当能正常调用时，断路器关闭。
关闭
当服务一直处于正常状态，能正常调用，断路器关闭。

### 如何使用springboot部署到不同的服务器

1、在一个项目中生成一个war文件。
2、将它部署到想要部署的服务器中（Tomcat、websphere、weblogic）

### JPA和Hibernate有哪些区别

简而言之：
1、JPA是一个规范或者接口
2、Hibernate是JPA的一个实现
当我们使用JPA的时候，我们使用javax.persistence包中的注释和接口时，不需要使用hibernate的导入包。

### 什么是spring cloud

Spring Cloud为开发人员提供了快速构建分布式系统的一些通用模式（例如配置管理，服务发现，断路器，智能路由，微代理，控制总线，一次性令牌，全局锁，领导选举，分布式会话，群集状态）。分布式系统的协调导致了锅炉板模式，并且使用Spring Cloud开发人员可以快速地站起来来实现这些模式的服务和应用程序。它们可以在任何分布式环境中正常工作，包括开发人员自己的笔记本电脑，裸机数据中心和受管平台，Cloud Foundry。

### Zookeeper是什么框架

分布式的、开源的分布式应用程序协调服务，原本是Hadoop、Hbase的一个重要组件，它为分布式应用提供一致性服务的软件，包括：配置维护、域名服务、分布式同步、组服务等。

**应用场景**：

Zookeeper的功能很强大，应用场景很多，Zookeeper主要是做注册中心用。基于Dubbo框架开发的提供者、消费者都向Zookeeper注册自己的URL，消费者还能拿到并订阅提供者的注册URL，一边在后续程序的执行中去调用提供者。而提供者发生了变动，也会通过Zookeeper向订阅的消费者发送通知。

Zookeeper**有哪几种节点类型**

节点类型可以分为**持久节点（PERSISTENT ）、临时节点（EPHEMERAL），以及时序节点（SEQUENTIAL ）**，具体在节点创建过程中，一般是组合使用，可以生成以下 4 种节点类型：

持久节点（PERSISTENT）
所谓持久节点，是指在节点创建后，就一直存在，直到有删除操作来主动清除这个节点——不会因为创建该节点的客户端会话失效而消失。
持久顺序节点（PERSISTENT_SEQUENTIAL ）
这类节点的基本特性和上面的节点类型是一致的。额外的特性是，在ZK中，每个父节点会为他的第一级子节点维护一份时序，会记录每个子节点创建的先后顺序。基于这个特性，在创建子节点的时候，可以设置这个属性，那么在创建节点过程中，ZK会自动为给定节点名加上一个数字后缀，作为新的节点名。这个数字后缀的上限是整型的最大值。
临时节点（EPHEMERAL ）
和持久节点不同的是，临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。注意，这里提到的是会话失效，而非连接断开。另外，在临时节点下面不能创建子节点。
临时顺序节点（EPHEMERAL_SEQUENTIAL）



