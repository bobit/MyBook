---
title: 源码分析相关
toc: true
typora-copy-images-to: ../../gitbooks/static/images/
mathjax: true
abbrlink: 9a84f5c8
date: 2017-12-28 17:17:35
tags:
  - Interview
categories:
  - Interview
---

## Java

### HashMap 与 HashTable 区别与应用场景

HashMap理解

- HashMap 是一个散列桶（数组和链表），它存储的内容是键值对 key-value 映射
- HashMap 采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改
- HashMap 是非 synchronized，所以 HashMap 很快
- HashMap 可以接受 null 键和值，而 Hashtable 则不能（原因就是 equlas() 方法需要对象，因为 HashMap 是后出的 API 经过处理才可以）
- HashMap 是基于 hashing 的原理，使用 put(key, value) 存储对象到 HashMap 中，使用 get(key) 从 HashMap 中获取对象。当给 put() 方法传递键和值时，先对键调用 hashCode() 方法，计算并返回的 hashCode 是用于找到 Map 数组的 bucket 位置来储存 Node 对象。

应用场景

推荐的HashMap应用场景是单线程运行环境，并且不需要遍历操作的场景。这个推荐场景不是硬性条件。比如多线程操作HashMap，通过加锁或者加入同步控制依然能正常应用HashMap，只是需要加上同步操作的代价。

多线程的环境推荐ConcurrentHashMap ，我们知道 Hashtable 是 synchronized 的，但是 ConcurrentHashMap 同步性能更好，因为它仅仅根据同步级别对 map 的一部分进行上锁ConcurrentHashMap 当然可以代替 HashTable，但是 HashTable 提供更强的线程安全性。它们都可以用于多线程的环境，但是当 Hashtable 的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。由于 ConcurrentHashMap 引入了分割（segmentation），不论它变得多么大，仅仅需要锁定 Map 的某个部分，其它的线程不需要等到迭代完成才能访问 Map。简而言之，在迭代的过程中，ConcurrentHashMap 仅仅锁定 Map 的某个部分，而 Hashtable 则会锁定整个 Map。

HashMap 与 HashTable 区别

- 继承和实现方式不同
  HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。
  Hashtable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。

- 默认容量不同
  HashMap**默认的容量大小是16**；增加容量时，每次将容量变为“原始容量x2”。
  Hashtable**默认的容量大小是11**；增加容量时，每次将容量变为“原始容量x2 + 1”。

- 线程安全性
  HashTable 安全

- 效率不同
  HashTable 要慢，因为加锁

- 对null值的处理不同
  HashMap的key、value**都可以为null**。
  Hashtable的key、value**都不可以为null**。

- 支持的遍历种类不同
  HashMap**只支持Iterator(迭代器)遍历。**
  而Hashtable**支持Iterator(迭代器)和Enumeration(枚举器)两种方式遍历。**

- 添加key-value时的hash值算法不同
  HashMap添加元素时，是使用**自定义的哈希算法。**
  Hashtable没有自定义哈希算法，而**直接采用的key的hashCode()。**

- 部分API不同
  Hashtable**支持contains(Object value)方法，而且重写了toString()方法**；
  而HashMap**不支持contains(Object value)方法，没有重写toString()方法。**

  

## Servlet

#### servlet执行流程

客户端发出http请求，web服务器将请求转发到servlet容器，servlet容器解析url并根据web.xml找到相对应的servlet，并将request、response对象传递给找到的servlet，servlet根据request就可以知道是谁发出的请求，请求信息及其他信息，当servlet处理完业务逻辑后会将信息放入到response并响应到客户端。



## 设计模式

单列模式，工厂模式，策略模式，共23种设计模式





## Spring5源码



## Mybatis源码



## Tomcat源码







